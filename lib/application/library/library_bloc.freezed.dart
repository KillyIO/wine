// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'library_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$LibraryEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() sessionFetched,
    required TResult Function(UniqueID uid) branchDeleted,
    required TResult Function(Branch branch) branchUpdated,
    required TResult Function(int index) pageViewIndexChanged,
    required TResult Function(UniqueID uid) treeDeleted,
    required TResult Function(Tree tree) treeUpdated,
    required TResult Function(int index) verticalNavbarIndexChanged,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? sessionFetched,
    TResult? Function(UniqueID uid)? branchDeleted,
    TResult? Function(Branch branch)? branchUpdated,
    TResult? Function(int index)? pageViewIndexChanged,
    TResult? Function(UniqueID uid)? treeDeleted,
    TResult? Function(Tree tree)? treeUpdated,
    TResult? Function(int index)? verticalNavbarIndexChanged,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? sessionFetched,
    TResult Function(UniqueID uid)? branchDeleted,
    TResult Function(Branch branch)? branchUpdated,
    TResult Function(int index)? pageViewIndexChanged,
    TResult Function(UniqueID uid)? treeDeleted,
    TResult Function(Tree tree)? treeUpdated,
    TResult Function(int index)? verticalNavbarIndexChanged,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Init value) init,
    required TResult Function(SessionFetched value) sessionFetched,
    required TResult Function(BranchDeleted value) branchDeleted,
    required TResult Function(BranchUpdated value) branchUpdated,
    required TResult Function(PageViewIndexChanged value) pageViewIndexChanged,
    required TResult Function(TreeDeleted value) treeDeleted,
    required TResult Function(TreeUpdated value) treeUpdated,
    required TResult Function(VerticalNavbarIndexChanged value)
        verticalNavbarIndexChanged,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Init value)? init,
    TResult? Function(SessionFetched value)? sessionFetched,
    TResult? Function(BranchDeleted value)? branchDeleted,
    TResult? Function(BranchUpdated value)? branchUpdated,
    TResult? Function(PageViewIndexChanged value)? pageViewIndexChanged,
    TResult? Function(TreeDeleted value)? treeDeleted,
    TResult? Function(TreeUpdated value)? treeUpdated,
    TResult? Function(VerticalNavbarIndexChanged value)?
        verticalNavbarIndexChanged,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Init value)? init,
    TResult Function(SessionFetched value)? sessionFetched,
    TResult Function(BranchDeleted value)? branchDeleted,
    TResult Function(BranchUpdated value)? branchUpdated,
    TResult Function(PageViewIndexChanged value)? pageViewIndexChanged,
    TResult Function(TreeDeleted value)? treeDeleted,
    TResult Function(TreeUpdated value)? treeUpdated,
    TResult Function(VerticalNavbarIndexChanged value)?
        verticalNavbarIndexChanged,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LibraryEventCopyWith<$Res> {
  factory $LibraryEventCopyWith(
          LibraryEvent value, $Res Function(LibraryEvent) then) =
      _$LibraryEventCopyWithImpl<$Res, LibraryEvent>;
}

/// @nodoc
class _$LibraryEventCopyWithImpl<$Res, $Val extends LibraryEvent>
    implements $LibraryEventCopyWith<$Res> {
  _$LibraryEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InitImplCopyWith<$Res> {
  factory _$$InitImplCopyWith(
          _$InitImpl value, $Res Function(_$InitImpl) then) =
      __$$InitImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitImplCopyWithImpl<$Res>
    extends _$LibraryEventCopyWithImpl<$Res, _$InitImpl>
    implements _$$InitImplCopyWith<$Res> {
  __$$InitImplCopyWithImpl(_$InitImpl _value, $Res Function(_$InitImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InitImpl implements Init {
  const _$InitImpl();

  @override
  String toString() {
    return 'LibraryEvent.init()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() sessionFetched,
    required TResult Function(UniqueID uid) branchDeleted,
    required TResult Function(Branch branch) branchUpdated,
    required TResult Function(int index) pageViewIndexChanged,
    required TResult Function(UniqueID uid) treeDeleted,
    required TResult Function(Tree tree) treeUpdated,
    required TResult Function(int index) verticalNavbarIndexChanged,
  }) {
    return init();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? sessionFetched,
    TResult? Function(UniqueID uid)? branchDeleted,
    TResult? Function(Branch branch)? branchUpdated,
    TResult? Function(int index)? pageViewIndexChanged,
    TResult? Function(UniqueID uid)? treeDeleted,
    TResult? Function(Tree tree)? treeUpdated,
    TResult? Function(int index)? verticalNavbarIndexChanged,
  }) {
    return init?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? sessionFetched,
    TResult Function(UniqueID uid)? branchDeleted,
    TResult Function(Branch branch)? branchUpdated,
    TResult Function(int index)? pageViewIndexChanged,
    TResult Function(UniqueID uid)? treeDeleted,
    TResult Function(Tree tree)? treeUpdated,
    TResult Function(int index)? verticalNavbarIndexChanged,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Init value) init,
    required TResult Function(SessionFetched value) sessionFetched,
    required TResult Function(BranchDeleted value) branchDeleted,
    required TResult Function(BranchUpdated value) branchUpdated,
    required TResult Function(PageViewIndexChanged value) pageViewIndexChanged,
    required TResult Function(TreeDeleted value) treeDeleted,
    required TResult Function(TreeUpdated value) treeUpdated,
    required TResult Function(VerticalNavbarIndexChanged value)
        verticalNavbarIndexChanged,
  }) {
    return init(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Init value)? init,
    TResult? Function(SessionFetched value)? sessionFetched,
    TResult? Function(BranchDeleted value)? branchDeleted,
    TResult? Function(BranchUpdated value)? branchUpdated,
    TResult? Function(PageViewIndexChanged value)? pageViewIndexChanged,
    TResult? Function(TreeDeleted value)? treeDeleted,
    TResult? Function(TreeUpdated value)? treeUpdated,
    TResult? Function(VerticalNavbarIndexChanged value)?
        verticalNavbarIndexChanged,
  }) {
    return init?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Init value)? init,
    TResult Function(SessionFetched value)? sessionFetched,
    TResult Function(BranchDeleted value)? branchDeleted,
    TResult Function(BranchUpdated value)? branchUpdated,
    TResult Function(PageViewIndexChanged value)? pageViewIndexChanged,
    TResult Function(TreeDeleted value)? treeDeleted,
    TResult Function(TreeUpdated value)? treeUpdated,
    TResult Function(VerticalNavbarIndexChanged value)?
        verticalNavbarIndexChanged,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init(this);
    }
    return orElse();
  }
}

abstract class Init implements LibraryEvent {
  const factory Init() = _$InitImpl;
}

/// @nodoc
abstract class _$$SessionFetchedImplCopyWith<$Res> {
  factory _$$SessionFetchedImplCopyWith(_$SessionFetchedImpl value,
          $Res Function(_$SessionFetchedImpl) then) =
      __$$SessionFetchedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SessionFetchedImplCopyWithImpl<$Res>
    extends _$LibraryEventCopyWithImpl<$Res, _$SessionFetchedImpl>
    implements _$$SessionFetchedImplCopyWith<$Res> {
  __$$SessionFetchedImplCopyWithImpl(
      _$SessionFetchedImpl _value, $Res Function(_$SessionFetchedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SessionFetchedImpl implements SessionFetched {
  const _$SessionFetchedImpl();

  @override
  String toString() {
    return 'LibraryEvent.sessionFetched()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$SessionFetchedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() sessionFetched,
    required TResult Function(UniqueID uid) branchDeleted,
    required TResult Function(Branch branch) branchUpdated,
    required TResult Function(int index) pageViewIndexChanged,
    required TResult Function(UniqueID uid) treeDeleted,
    required TResult Function(Tree tree) treeUpdated,
    required TResult Function(int index) verticalNavbarIndexChanged,
  }) {
    return sessionFetched();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? sessionFetched,
    TResult? Function(UniqueID uid)? branchDeleted,
    TResult? Function(Branch branch)? branchUpdated,
    TResult? Function(int index)? pageViewIndexChanged,
    TResult? Function(UniqueID uid)? treeDeleted,
    TResult? Function(Tree tree)? treeUpdated,
    TResult? Function(int index)? verticalNavbarIndexChanged,
  }) {
    return sessionFetched?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? sessionFetched,
    TResult Function(UniqueID uid)? branchDeleted,
    TResult Function(Branch branch)? branchUpdated,
    TResult Function(int index)? pageViewIndexChanged,
    TResult Function(UniqueID uid)? treeDeleted,
    TResult Function(Tree tree)? treeUpdated,
    TResult Function(int index)? verticalNavbarIndexChanged,
    required TResult orElse(),
  }) {
    if (sessionFetched != null) {
      return sessionFetched();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Init value) init,
    required TResult Function(SessionFetched value) sessionFetched,
    required TResult Function(BranchDeleted value) branchDeleted,
    required TResult Function(BranchUpdated value) branchUpdated,
    required TResult Function(PageViewIndexChanged value) pageViewIndexChanged,
    required TResult Function(TreeDeleted value) treeDeleted,
    required TResult Function(TreeUpdated value) treeUpdated,
    required TResult Function(VerticalNavbarIndexChanged value)
        verticalNavbarIndexChanged,
  }) {
    return sessionFetched(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Init value)? init,
    TResult? Function(SessionFetched value)? sessionFetched,
    TResult? Function(BranchDeleted value)? branchDeleted,
    TResult? Function(BranchUpdated value)? branchUpdated,
    TResult? Function(PageViewIndexChanged value)? pageViewIndexChanged,
    TResult? Function(TreeDeleted value)? treeDeleted,
    TResult? Function(TreeUpdated value)? treeUpdated,
    TResult? Function(VerticalNavbarIndexChanged value)?
        verticalNavbarIndexChanged,
  }) {
    return sessionFetched?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Init value)? init,
    TResult Function(SessionFetched value)? sessionFetched,
    TResult Function(BranchDeleted value)? branchDeleted,
    TResult Function(BranchUpdated value)? branchUpdated,
    TResult Function(PageViewIndexChanged value)? pageViewIndexChanged,
    TResult Function(TreeDeleted value)? treeDeleted,
    TResult Function(TreeUpdated value)? treeUpdated,
    TResult Function(VerticalNavbarIndexChanged value)?
        verticalNavbarIndexChanged,
    required TResult orElse(),
  }) {
    if (sessionFetched != null) {
      return sessionFetched(this);
    }
    return orElse();
  }
}

abstract class SessionFetched implements LibraryEvent {
  const factory SessionFetched() = _$SessionFetchedImpl;
}

/// @nodoc
abstract class _$$BranchDeletedImplCopyWith<$Res> {
  factory _$$BranchDeletedImplCopyWith(
          _$BranchDeletedImpl value, $Res Function(_$BranchDeletedImpl) then) =
      __$$BranchDeletedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({UniqueID uid});
}

/// @nodoc
class __$$BranchDeletedImplCopyWithImpl<$Res>
    extends _$LibraryEventCopyWithImpl<$Res, _$BranchDeletedImpl>
    implements _$$BranchDeletedImplCopyWith<$Res> {
  __$$BranchDeletedImplCopyWithImpl(
      _$BranchDeletedImpl _value, $Res Function(_$BranchDeletedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? uid = null,
  }) {
    return _then(_$BranchDeletedImpl(
      null == uid
          ? _value.uid
          : uid // ignore: cast_nullable_to_non_nullable
              as UniqueID,
    ));
  }
}

/// @nodoc

class _$BranchDeletedImpl implements BranchDeleted {
  const _$BranchDeletedImpl(this.uid);

  @override
  final UniqueID uid;

  @override
  String toString() {
    return 'LibraryEvent.branchDeleted(uid: $uid)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BranchDeletedImpl &&
            (identical(other.uid, uid) || other.uid == uid));
  }

  @override
  int get hashCode => Object.hash(runtimeType, uid);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BranchDeletedImplCopyWith<_$BranchDeletedImpl> get copyWith =>
      __$$BranchDeletedImplCopyWithImpl<_$BranchDeletedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() sessionFetched,
    required TResult Function(UniqueID uid) branchDeleted,
    required TResult Function(Branch branch) branchUpdated,
    required TResult Function(int index) pageViewIndexChanged,
    required TResult Function(UniqueID uid) treeDeleted,
    required TResult Function(Tree tree) treeUpdated,
    required TResult Function(int index) verticalNavbarIndexChanged,
  }) {
    return branchDeleted(uid);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? sessionFetched,
    TResult? Function(UniqueID uid)? branchDeleted,
    TResult? Function(Branch branch)? branchUpdated,
    TResult? Function(int index)? pageViewIndexChanged,
    TResult? Function(UniqueID uid)? treeDeleted,
    TResult? Function(Tree tree)? treeUpdated,
    TResult? Function(int index)? verticalNavbarIndexChanged,
  }) {
    return branchDeleted?.call(uid);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? sessionFetched,
    TResult Function(UniqueID uid)? branchDeleted,
    TResult Function(Branch branch)? branchUpdated,
    TResult Function(int index)? pageViewIndexChanged,
    TResult Function(UniqueID uid)? treeDeleted,
    TResult Function(Tree tree)? treeUpdated,
    TResult Function(int index)? verticalNavbarIndexChanged,
    required TResult orElse(),
  }) {
    if (branchDeleted != null) {
      return branchDeleted(uid);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Init value) init,
    required TResult Function(SessionFetched value) sessionFetched,
    required TResult Function(BranchDeleted value) branchDeleted,
    required TResult Function(BranchUpdated value) branchUpdated,
    required TResult Function(PageViewIndexChanged value) pageViewIndexChanged,
    required TResult Function(TreeDeleted value) treeDeleted,
    required TResult Function(TreeUpdated value) treeUpdated,
    required TResult Function(VerticalNavbarIndexChanged value)
        verticalNavbarIndexChanged,
  }) {
    return branchDeleted(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Init value)? init,
    TResult? Function(SessionFetched value)? sessionFetched,
    TResult? Function(BranchDeleted value)? branchDeleted,
    TResult? Function(BranchUpdated value)? branchUpdated,
    TResult? Function(PageViewIndexChanged value)? pageViewIndexChanged,
    TResult? Function(TreeDeleted value)? treeDeleted,
    TResult? Function(TreeUpdated value)? treeUpdated,
    TResult? Function(VerticalNavbarIndexChanged value)?
        verticalNavbarIndexChanged,
  }) {
    return branchDeleted?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Init value)? init,
    TResult Function(SessionFetched value)? sessionFetched,
    TResult Function(BranchDeleted value)? branchDeleted,
    TResult Function(BranchUpdated value)? branchUpdated,
    TResult Function(PageViewIndexChanged value)? pageViewIndexChanged,
    TResult Function(TreeDeleted value)? treeDeleted,
    TResult Function(TreeUpdated value)? treeUpdated,
    TResult Function(VerticalNavbarIndexChanged value)?
        verticalNavbarIndexChanged,
    required TResult orElse(),
  }) {
    if (branchDeleted != null) {
      return branchDeleted(this);
    }
    return orElse();
  }
}

abstract class BranchDeleted implements LibraryEvent {
  const factory BranchDeleted(final UniqueID uid) = _$BranchDeletedImpl;

  UniqueID get uid;
  @JsonKey(ignore: true)
  _$$BranchDeletedImplCopyWith<_$BranchDeletedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BranchUpdatedImplCopyWith<$Res> {
  factory _$$BranchUpdatedImplCopyWith(
          _$BranchUpdatedImpl value, $Res Function(_$BranchUpdatedImpl) then) =
      __$$BranchUpdatedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Branch branch});

  $BranchCopyWith<$Res> get branch;
}

/// @nodoc
class __$$BranchUpdatedImplCopyWithImpl<$Res>
    extends _$LibraryEventCopyWithImpl<$Res, _$BranchUpdatedImpl>
    implements _$$BranchUpdatedImplCopyWith<$Res> {
  __$$BranchUpdatedImplCopyWithImpl(
      _$BranchUpdatedImpl _value, $Res Function(_$BranchUpdatedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? branch = null,
  }) {
    return _then(_$BranchUpdatedImpl(
      null == branch
          ? _value.branch
          : branch // ignore: cast_nullable_to_non_nullable
              as Branch,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $BranchCopyWith<$Res> get branch {
    return $BranchCopyWith<$Res>(_value.branch, (value) {
      return _then(_value.copyWith(branch: value));
    });
  }
}

/// @nodoc

class _$BranchUpdatedImpl implements BranchUpdated {
  const _$BranchUpdatedImpl(this.branch);

  @override
  final Branch branch;

  @override
  String toString() {
    return 'LibraryEvent.branchUpdated(branch: $branch)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BranchUpdatedImpl &&
            (identical(other.branch, branch) || other.branch == branch));
  }

  @override
  int get hashCode => Object.hash(runtimeType, branch);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BranchUpdatedImplCopyWith<_$BranchUpdatedImpl> get copyWith =>
      __$$BranchUpdatedImplCopyWithImpl<_$BranchUpdatedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() sessionFetched,
    required TResult Function(UniqueID uid) branchDeleted,
    required TResult Function(Branch branch) branchUpdated,
    required TResult Function(int index) pageViewIndexChanged,
    required TResult Function(UniqueID uid) treeDeleted,
    required TResult Function(Tree tree) treeUpdated,
    required TResult Function(int index) verticalNavbarIndexChanged,
  }) {
    return branchUpdated(branch);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? sessionFetched,
    TResult? Function(UniqueID uid)? branchDeleted,
    TResult? Function(Branch branch)? branchUpdated,
    TResult? Function(int index)? pageViewIndexChanged,
    TResult? Function(UniqueID uid)? treeDeleted,
    TResult? Function(Tree tree)? treeUpdated,
    TResult? Function(int index)? verticalNavbarIndexChanged,
  }) {
    return branchUpdated?.call(branch);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? sessionFetched,
    TResult Function(UniqueID uid)? branchDeleted,
    TResult Function(Branch branch)? branchUpdated,
    TResult Function(int index)? pageViewIndexChanged,
    TResult Function(UniqueID uid)? treeDeleted,
    TResult Function(Tree tree)? treeUpdated,
    TResult Function(int index)? verticalNavbarIndexChanged,
    required TResult orElse(),
  }) {
    if (branchUpdated != null) {
      return branchUpdated(branch);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Init value) init,
    required TResult Function(SessionFetched value) sessionFetched,
    required TResult Function(BranchDeleted value) branchDeleted,
    required TResult Function(BranchUpdated value) branchUpdated,
    required TResult Function(PageViewIndexChanged value) pageViewIndexChanged,
    required TResult Function(TreeDeleted value) treeDeleted,
    required TResult Function(TreeUpdated value) treeUpdated,
    required TResult Function(VerticalNavbarIndexChanged value)
        verticalNavbarIndexChanged,
  }) {
    return branchUpdated(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Init value)? init,
    TResult? Function(SessionFetched value)? sessionFetched,
    TResult? Function(BranchDeleted value)? branchDeleted,
    TResult? Function(BranchUpdated value)? branchUpdated,
    TResult? Function(PageViewIndexChanged value)? pageViewIndexChanged,
    TResult? Function(TreeDeleted value)? treeDeleted,
    TResult? Function(TreeUpdated value)? treeUpdated,
    TResult? Function(VerticalNavbarIndexChanged value)?
        verticalNavbarIndexChanged,
  }) {
    return branchUpdated?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Init value)? init,
    TResult Function(SessionFetched value)? sessionFetched,
    TResult Function(BranchDeleted value)? branchDeleted,
    TResult Function(BranchUpdated value)? branchUpdated,
    TResult Function(PageViewIndexChanged value)? pageViewIndexChanged,
    TResult Function(TreeDeleted value)? treeDeleted,
    TResult Function(TreeUpdated value)? treeUpdated,
    TResult Function(VerticalNavbarIndexChanged value)?
        verticalNavbarIndexChanged,
    required TResult orElse(),
  }) {
    if (branchUpdated != null) {
      return branchUpdated(this);
    }
    return orElse();
  }
}

abstract class BranchUpdated implements LibraryEvent {
  const factory BranchUpdated(final Branch branch) = _$BranchUpdatedImpl;

  Branch get branch;
  @JsonKey(ignore: true)
  _$$BranchUpdatedImplCopyWith<_$BranchUpdatedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PageViewIndexChangedImplCopyWith<$Res> {
  factory _$$PageViewIndexChangedImplCopyWith(_$PageViewIndexChangedImpl value,
          $Res Function(_$PageViewIndexChangedImpl) then) =
      __$$PageViewIndexChangedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int index});
}

/// @nodoc
class __$$PageViewIndexChangedImplCopyWithImpl<$Res>
    extends _$LibraryEventCopyWithImpl<$Res, _$PageViewIndexChangedImpl>
    implements _$$PageViewIndexChangedImplCopyWith<$Res> {
  __$$PageViewIndexChangedImplCopyWithImpl(_$PageViewIndexChangedImpl _value,
      $Res Function(_$PageViewIndexChangedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
  }) {
    return _then(_$PageViewIndexChangedImpl(
      null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$PageViewIndexChangedImpl implements PageViewIndexChanged {
  const _$PageViewIndexChangedImpl(this.index);

  @override
  final int index;

  @override
  String toString() {
    return 'LibraryEvent.pageViewIndexChanged(index: $index)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PageViewIndexChangedImpl &&
            (identical(other.index, index) || other.index == index));
  }

  @override
  int get hashCode => Object.hash(runtimeType, index);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PageViewIndexChangedImplCopyWith<_$PageViewIndexChangedImpl>
      get copyWith =>
          __$$PageViewIndexChangedImplCopyWithImpl<_$PageViewIndexChangedImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() sessionFetched,
    required TResult Function(UniqueID uid) branchDeleted,
    required TResult Function(Branch branch) branchUpdated,
    required TResult Function(int index) pageViewIndexChanged,
    required TResult Function(UniqueID uid) treeDeleted,
    required TResult Function(Tree tree) treeUpdated,
    required TResult Function(int index) verticalNavbarIndexChanged,
  }) {
    return pageViewIndexChanged(index);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? sessionFetched,
    TResult? Function(UniqueID uid)? branchDeleted,
    TResult? Function(Branch branch)? branchUpdated,
    TResult? Function(int index)? pageViewIndexChanged,
    TResult? Function(UniqueID uid)? treeDeleted,
    TResult? Function(Tree tree)? treeUpdated,
    TResult? Function(int index)? verticalNavbarIndexChanged,
  }) {
    return pageViewIndexChanged?.call(index);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? sessionFetched,
    TResult Function(UniqueID uid)? branchDeleted,
    TResult Function(Branch branch)? branchUpdated,
    TResult Function(int index)? pageViewIndexChanged,
    TResult Function(UniqueID uid)? treeDeleted,
    TResult Function(Tree tree)? treeUpdated,
    TResult Function(int index)? verticalNavbarIndexChanged,
    required TResult orElse(),
  }) {
    if (pageViewIndexChanged != null) {
      return pageViewIndexChanged(index);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Init value) init,
    required TResult Function(SessionFetched value) sessionFetched,
    required TResult Function(BranchDeleted value) branchDeleted,
    required TResult Function(BranchUpdated value) branchUpdated,
    required TResult Function(PageViewIndexChanged value) pageViewIndexChanged,
    required TResult Function(TreeDeleted value) treeDeleted,
    required TResult Function(TreeUpdated value) treeUpdated,
    required TResult Function(VerticalNavbarIndexChanged value)
        verticalNavbarIndexChanged,
  }) {
    return pageViewIndexChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Init value)? init,
    TResult? Function(SessionFetched value)? sessionFetched,
    TResult? Function(BranchDeleted value)? branchDeleted,
    TResult? Function(BranchUpdated value)? branchUpdated,
    TResult? Function(PageViewIndexChanged value)? pageViewIndexChanged,
    TResult? Function(TreeDeleted value)? treeDeleted,
    TResult? Function(TreeUpdated value)? treeUpdated,
    TResult? Function(VerticalNavbarIndexChanged value)?
        verticalNavbarIndexChanged,
  }) {
    return pageViewIndexChanged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Init value)? init,
    TResult Function(SessionFetched value)? sessionFetched,
    TResult Function(BranchDeleted value)? branchDeleted,
    TResult Function(BranchUpdated value)? branchUpdated,
    TResult Function(PageViewIndexChanged value)? pageViewIndexChanged,
    TResult Function(TreeDeleted value)? treeDeleted,
    TResult Function(TreeUpdated value)? treeUpdated,
    TResult Function(VerticalNavbarIndexChanged value)?
        verticalNavbarIndexChanged,
    required TResult orElse(),
  }) {
    if (pageViewIndexChanged != null) {
      return pageViewIndexChanged(this);
    }
    return orElse();
  }
}

abstract class PageViewIndexChanged implements LibraryEvent {
  const factory PageViewIndexChanged(final int index) =
      _$PageViewIndexChangedImpl;

  int get index;
  @JsonKey(ignore: true)
  _$$PageViewIndexChangedImplCopyWith<_$PageViewIndexChangedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$TreeDeletedImplCopyWith<$Res> {
  factory _$$TreeDeletedImplCopyWith(
          _$TreeDeletedImpl value, $Res Function(_$TreeDeletedImpl) then) =
      __$$TreeDeletedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({UniqueID uid});
}

/// @nodoc
class __$$TreeDeletedImplCopyWithImpl<$Res>
    extends _$LibraryEventCopyWithImpl<$Res, _$TreeDeletedImpl>
    implements _$$TreeDeletedImplCopyWith<$Res> {
  __$$TreeDeletedImplCopyWithImpl(
      _$TreeDeletedImpl _value, $Res Function(_$TreeDeletedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? uid = null,
  }) {
    return _then(_$TreeDeletedImpl(
      null == uid
          ? _value.uid
          : uid // ignore: cast_nullable_to_non_nullable
              as UniqueID,
    ));
  }
}

/// @nodoc

class _$TreeDeletedImpl implements TreeDeleted {
  const _$TreeDeletedImpl(this.uid);

  @override
  final UniqueID uid;

  @override
  String toString() {
    return 'LibraryEvent.treeDeleted(uid: $uid)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TreeDeletedImpl &&
            (identical(other.uid, uid) || other.uid == uid));
  }

  @override
  int get hashCode => Object.hash(runtimeType, uid);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TreeDeletedImplCopyWith<_$TreeDeletedImpl> get copyWith =>
      __$$TreeDeletedImplCopyWithImpl<_$TreeDeletedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() sessionFetched,
    required TResult Function(UniqueID uid) branchDeleted,
    required TResult Function(Branch branch) branchUpdated,
    required TResult Function(int index) pageViewIndexChanged,
    required TResult Function(UniqueID uid) treeDeleted,
    required TResult Function(Tree tree) treeUpdated,
    required TResult Function(int index) verticalNavbarIndexChanged,
  }) {
    return treeDeleted(uid);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? sessionFetched,
    TResult? Function(UniqueID uid)? branchDeleted,
    TResult? Function(Branch branch)? branchUpdated,
    TResult? Function(int index)? pageViewIndexChanged,
    TResult? Function(UniqueID uid)? treeDeleted,
    TResult? Function(Tree tree)? treeUpdated,
    TResult? Function(int index)? verticalNavbarIndexChanged,
  }) {
    return treeDeleted?.call(uid);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? sessionFetched,
    TResult Function(UniqueID uid)? branchDeleted,
    TResult Function(Branch branch)? branchUpdated,
    TResult Function(int index)? pageViewIndexChanged,
    TResult Function(UniqueID uid)? treeDeleted,
    TResult Function(Tree tree)? treeUpdated,
    TResult Function(int index)? verticalNavbarIndexChanged,
    required TResult orElse(),
  }) {
    if (treeDeleted != null) {
      return treeDeleted(uid);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Init value) init,
    required TResult Function(SessionFetched value) sessionFetched,
    required TResult Function(BranchDeleted value) branchDeleted,
    required TResult Function(BranchUpdated value) branchUpdated,
    required TResult Function(PageViewIndexChanged value) pageViewIndexChanged,
    required TResult Function(TreeDeleted value) treeDeleted,
    required TResult Function(TreeUpdated value) treeUpdated,
    required TResult Function(VerticalNavbarIndexChanged value)
        verticalNavbarIndexChanged,
  }) {
    return treeDeleted(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Init value)? init,
    TResult? Function(SessionFetched value)? sessionFetched,
    TResult? Function(BranchDeleted value)? branchDeleted,
    TResult? Function(BranchUpdated value)? branchUpdated,
    TResult? Function(PageViewIndexChanged value)? pageViewIndexChanged,
    TResult? Function(TreeDeleted value)? treeDeleted,
    TResult? Function(TreeUpdated value)? treeUpdated,
    TResult? Function(VerticalNavbarIndexChanged value)?
        verticalNavbarIndexChanged,
  }) {
    return treeDeleted?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Init value)? init,
    TResult Function(SessionFetched value)? sessionFetched,
    TResult Function(BranchDeleted value)? branchDeleted,
    TResult Function(BranchUpdated value)? branchUpdated,
    TResult Function(PageViewIndexChanged value)? pageViewIndexChanged,
    TResult Function(TreeDeleted value)? treeDeleted,
    TResult Function(TreeUpdated value)? treeUpdated,
    TResult Function(VerticalNavbarIndexChanged value)?
        verticalNavbarIndexChanged,
    required TResult orElse(),
  }) {
    if (treeDeleted != null) {
      return treeDeleted(this);
    }
    return orElse();
  }
}

abstract class TreeDeleted implements LibraryEvent {
  const factory TreeDeleted(final UniqueID uid) = _$TreeDeletedImpl;

  UniqueID get uid;
  @JsonKey(ignore: true)
  _$$TreeDeletedImplCopyWith<_$TreeDeletedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$TreeUpdatedImplCopyWith<$Res> {
  factory _$$TreeUpdatedImplCopyWith(
          _$TreeUpdatedImpl value, $Res Function(_$TreeUpdatedImpl) then) =
      __$$TreeUpdatedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Tree tree});

  $TreeCopyWith<$Res> get tree;
}

/// @nodoc
class __$$TreeUpdatedImplCopyWithImpl<$Res>
    extends _$LibraryEventCopyWithImpl<$Res, _$TreeUpdatedImpl>
    implements _$$TreeUpdatedImplCopyWith<$Res> {
  __$$TreeUpdatedImplCopyWithImpl(
      _$TreeUpdatedImpl _value, $Res Function(_$TreeUpdatedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? tree = null,
  }) {
    return _then(_$TreeUpdatedImpl(
      null == tree
          ? _value.tree
          : tree // ignore: cast_nullable_to_non_nullable
              as Tree,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $TreeCopyWith<$Res> get tree {
    return $TreeCopyWith<$Res>(_value.tree, (value) {
      return _then(_value.copyWith(tree: value));
    });
  }
}

/// @nodoc

class _$TreeUpdatedImpl implements TreeUpdated {
  const _$TreeUpdatedImpl(this.tree);

  @override
  final Tree tree;

  @override
  String toString() {
    return 'LibraryEvent.treeUpdated(tree: $tree)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TreeUpdatedImpl &&
            (identical(other.tree, tree) || other.tree == tree));
  }

  @override
  int get hashCode => Object.hash(runtimeType, tree);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TreeUpdatedImplCopyWith<_$TreeUpdatedImpl> get copyWith =>
      __$$TreeUpdatedImplCopyWithImpl<_$TreeUpdatedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() sessionFetched,
    required TResult Function(UniqueID uid) branchDeleted,
    required TResult Function(Branch branch) branchUpdated,
    required TResult Function(int index) pageViewIndexChanged,
    required TResult Function(UniqueID uid) treeDeleted,
    required TResult Function(Tree tree) treeUpdated,
    required TResult Function(int index) verticalNavbarIndexChanged,
  }) {
    return treeUpdated(tree);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? sessionFetched,
    TResult? Function(UniqueID uid)? branchDeleted,
    TResult? Function(Branch branch)? branchUpdated,
    TResult? Function(int index)? pageViewIndexChanged,
    TResult? Function(UniqueID uid)? treeDeleted,
    TResult? Function(Tree tree)? treeUpdated,
    TResult? Function(int index)? verticalNavbarIndexChanged,
  }) {
    return treeUpdated?.call(tree);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? sessionFetched,
    TResult Function(UniqueID uid)? branchDeleted,
    TResult Function(Branch branch)? branchUpdated,
    TResult Function(int index)? pageViewIndexChanged,
    TResult Function(UniqueID uid)? treeDeleted,
    TResult Function(Tree tree)? treeUpdated,
    TResult Function(int index)? verticalNavbarIndexChanged,
    required TResult orElse(),
  }) {
    if (treeUpdated != null) {
      return treeUpdated(tree);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Init value) init,
    required TResult Function(SessionFetched value) sessionFetched,
    required TResult Function(BranchDeleted value) branchDeleted,
    required TResult Function(BranchUpdated value) branchUpdated,
    required TResult Function(PageViewIndexChanged value) pageViewIndexChanged,
    required TResult Function(TreeDeleted value) treeDeleted,
    required TResult Function(TreeUpdated value) treeUpdated,
    required TResult Function(VerticalNavbarIndexChanged value)
        verticalNavbarIndexChanged,
  }) {
    return treeUpdated(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Init value)? init,
    TResult? Function(SessionFetched value)? sessionFetched,
    TResult? Function(BranchDeleted value)? branchDeleted,
    TResult? Function(BranchUpdated value)? branchUpdated,
    TResult? Function(PageViewIndexChanged value)? pageViewIndexChanged,
    TResult? Function(TreeDeleted value)? treeDeleted,
    TResult? Function(TreeUpdated value)? treeUpdated,
    TResult? Function(VerticalNavbarIndexChanged value)?
        verticalNavbarIndexChanged,
  }) {
    return treeUpdated?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Init value)? init,
    TResult Function(SessionFetched value)? sessionFetched,
    TResult Function(BranchDeleted value)? branchDeleted,
    TResult Function(BranchUpdated value)? branchUpdated,
    TResult Function(PageViewIndexChanged value)? pageViewIndexChanged,
    TResult Function(TreeDeleted value)? treeDeleted,
    TResult Function(TreeUpdated value)? treeUpdated,
    TResult Function(VerticalNavbarIndexChanged value)?
        verticalNavbarIndexChanged,
    required TResult orElse(),
  }) {
    if (treeUpdated != null) {
      return treeUpdated(this);
    }
    return orElse();
  }
}

abstract class TreeUpdated implements LibraryEvent {
  const factory TreeUpdated(final Tree tree) = _$TreeUpdatedImpl;

  Tree get tree;
  @JsonKey(ignore: true)
  _$$TreeUpdatedImplCopyWith<_$TreeUpdatedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$VerticalNavbarIndexChangedImplCopyWith<$Res> {
  factory _$$VerticalNavbarIndexChangedImplCopyWith(
          _$VerticalNavbarIndexChangedImpl value,
          $Res Function(_$VerticalNavbarIndexChangedImpl) then) =
      __$$VerticalNavbarIndexChangedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int index});
}

/// @nodoc
class __$$VerticalNavbarIndexChangedImplCopyWithImpl<$Res>
    extends _$LibraryEventCopyWithImpl<$Res, _$VerticalNavbarIndexChangedImpl>
    implements _$$VerticalNavbarIndexChangedImplCopyWith<$Res> {
  __$$VerticalNavbarIndexChangedImplCopyWithImpl(
      _$VerticalNavbarIndexChangedImpl _value,
      $Res Function(_$VerticalNavbarIndexChangedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
  }) {
    return _then(_$VerticalNavbarIndexChangedImpl(
      null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$VerticalNavbarIndexChangedImpl implements VerticalNavbarIndexChanged {
  const _$VerticalNavbarIndexChangedImpl(this.index);

  @override
  final int index;

  @override
  String toString() {
    return 'LibraryEvent.verticalNavbarIndexChanged(index: $index)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$VerticalNavbarIndexChangedImpl &&
            (identical(other.index, index) || other.index == index));
  }

  @override
  int get hashCode => Object.hash(runtimeType, index);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$VerticalNavbarIndexChangedImplCopyWith<_$VerticalNavbarIndexChangedImpl>
      get copyWith => __$$VerticalNavbarIndexChangedImplCopyWithImpl<
          _$VerticalNavbarIndexChangedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() sessionFetched,
    required TResult Function(UniqueID uid) branchDeleted,
    required TResult Function(Branch branch) branchUpdated,
    required TResult Function(int index) pageViewIndexChanged,
    required TResult Function(UniqueID uid) treeDeleted,
    required TResult Function(Tree tree) treeUpdated,
    required TResult Function(int index) verticalNavbarIndexChanged,
  }) {
    return verticalNavbarIndexChanged(index);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? sessionFetched,
    TResult? Function(UniqueID uid)? branchDeleted,
    TResult? Function(Branch branch)? branchUpdated,
    TResult? Function(int index)? pageViewIndexChanged,
    TResult? Function(UniqueID uid)? treeDeleted,
    TResult? Function(Tree tree)? treeUpdated,
    TResult? Function(int index)? verticalNavbarIndexChanged,
  }) {
    return verticalNavbarIndexChanged?.call(index);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? sessionFetched,
    TResult Function(UniqueID uid)? branchDeleted,
    TResult Function(Branch branch)? branchUpdated,
    TResult Function(int index)? pageViewIndexChanged,
    TResult Function(UniqueID uid)? treeDeleted,
    TResult Function(Tree tree)? treeUpdated,
    TResult Function(int index)? verticalNavbarIndexChanged,
    required TResult orElse(),
  }) {
    if (verticalNavbarIndexChanged != null) {
      return verticalNavbarIndexChanged(index);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Init value) init,
    required TResult Function(SessionFetched value) sessionFetched,
    required TResult Function(BranchDeleted value) branchDeleted,
    required TResult Function(BranchUpdated value) branchUpdated,
    required TResult Function(PageViewIndexChanged value) pageViewIndexChanged,
    required TResult Function(TreeDeleted value) treeDeleted,
    required TResult Function(TreeUpdated value) treeUpdated,
    required TResult Function(VerticalNavbarIndexChanged value)
        verticalNavbarIndexChanged,
  }) {
    return verticalNavbarIndexChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Init value)? init,
    TResult? Function(SessionFetched value)? sessionFetched,
    TResult? Function(BranchDeleted value)? branchDeleted,
    TResult? Function(BranchUpdated value)? branchUpdated,
    TResult? Function(PageViewIndexChanged value)? pageViewIndexChanged,
    TResult? Function(TreeDeleted value)? treeDeleted,
    TResult? Function(TreeUpdated value)? treeUpdated,
    TResult? Function(VerticalNavbarIndexChanged value)?
        verticalNavbarIndexChanged,
  }) {
    return verticalNavbarIndexChanged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Init value)? init,
    TResult Function(SessionFetched value)? sessionFetched,
    TResult Function(BranchDeleted value)? branchDeleted,
    TResult Function(BranchUpdated value)? branchUpdated,
    TResult Function(PageViewIndexChanged value)? pageViewIndexChanged,
    TResult Function(TreeDeleted value)? treeDeleted,
    TResult Function(TreeUpdated value)? treeUpdated,
    TResult Function(VerticalNavbarIndexChanged value)?
        verticalNavbarIndexChanged,
    required TResult orElse(),
  }) {
    if (verticalNavbarIndexChanged != null) {
      return verticalNavbarIndexChanged(this);
    }
    return orElse();
  }
}

abstract class VerticalNavbarIndexChanged implements LibraryEvent {
  const factory VerticalNavbarIndexChanged(final int index) =
      _$VerticalNavbarIndexChangedImpl;

  int get index;
  @JsonKey(ignore: true)
  _$$VerticalNavbarIndexChangedImplCopyWith<_$VerticalNavbarIndexChangedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$LibraryState {
  List<Branch> get bookmarkedBranches => throw _privateConstructorUsedError;
  List<Tree> get bookmarkedTree => throw _privateConstructorUsedError;
  List<Branch> get branches => throw _privateConstructorUsedError;
  int get currentPageViewIdx => throw _privateConstructorUsedError;
  int get currentVerticalNavbarIdx => throw _privateConstructorUsedError;
  Option<Result<None<Object>, CoreFailure>> get failureOption =>
      throw _privateConstructorUsedError;
  bool get isProcessing => throw _privateConstructorUsedError;
  User get session => throw _privateConstructorUsedError;
  List<Tree> get trees => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $LibraryStateCopyWith<LibraryState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LibraryStateCopyWith<$Res> {
  factory $LibraryStateCopyWith(
          LibraryState value, $Res Function(LibraryState) then) =
      _$LibraryStateCopyWithImpl<$Res, LibraryState>;
  @useResult
  $Res call(
      {List<Branch> bookmarkedBranches,
      List<Tree> bookmarkedTree,
      List<Branch> branches,
      int currentPageViewIdx,
      int currentVerticalNavbarIdx,
      Option<Result<None<Object>, CoreFailure>> failureOption,
      bool isProcessing,
      User session,
      List<Tree> trees});

  $UserCopyWith<$Res> get session;
}

/// @nodoc
class _$LibraryStateCopyWithImpl<$Res, $Val extends LibraryState>
    implements $LibraryStateCopyWith<$Res> {
  _$LibraryStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? bookmarkedBranches = null,
    Object? bookmarkedTree = null,
    Object? branches = null,
    Object? currentPageViewIdx = null,
    Object? currentVerticalNavbarIdx = null,
    Object? failureOption = null,
    Object? isProcessing = null,
    Object? session = null,
    Object? trees = null,
  }) {
    return _then(_value.copyWith(
      bookmarkedBranches: null == bookmarkedBranches
          ? _value.bookmarkedBranches
          : bookmarkedBranches // ignore: cast_nullable_to_non_nullable
              as List<Branch>,
      bookmarkedTree: null == bookmarkedTree
          ? _value.bookmarkedTree
          : bookmarkedTree // ignore: cast_nullable_to_non_nullable
              as List<Tree>,
      branches: null == branches
          ? _value.branches
          : branches // ignore: cast_nullable_to_non_nullable
              as List<Branch>,
      currentPageViewIdx: null == currentPageViewIdx
          ? _value.currentPageViewIdx
          : currentPageViewIdx // ignore: cast_nullable_to_non_nullable
              as int,
      currentVerticalNavbarIdx: null == currentVerticalNavbarIdx
          ? _value.currentVerticalNavbarIdx
          : currentVerticalNavbarIdx // ignore: cast_nullable_to_non_nullable
              as int,
      failureOption: null == failureOption
          ? _value.failureOption
          : failureOption // ignore: cast_nullable_to_non_nullable
              as Option<Result<None<Object>, CoreFailure>>,
      isProcessing: null == isProcessing
          ? _value.isProcessing
          : isProcessing // ignore: cast_nullable_to_non_nullable
              as bool,
      session: null == session
          ? _value.session
          : session // ignore: cast_nullable_to_non_nullable
              as User,
      trees: null == trees
          ? _value.trees
          : trees // ignore: cast_nullable_to_non_nullable
              as List<Tree>,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $UserCopyWith<$Res> get session {
    return $UserCopyWith<$Res>(_value.session, (value) {
      return _then(_value.copyWith(session: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$LibraryStateImplCopyWith<$Res>
    implements $LibraryStateCopyWith<$Res> {
  factory _$$LibraryStateImplCopyWith(
          _$LibraryStateImpl value, $Res Function(_$LibraryStateImpl) then) =
      __$$LibraryStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<Branch> bookmarkedBranches,
      List<Tree> bookmarkedTree,
      List<Branch> branches,
      int currentPageViewIdx,
      int currentVerticalNavbarIdx,
      Option<Result<None<Object>, CoreFailure>> failureOption,
      bool isProcessing,
      User session,
      List<Tree> trees});

  @override
  $UserCopyWith<$Res> get session;
}

/// @nodoc
class __$$LibraryStateImplCopyWithImpl<$Res>
    extends _$LibraryStateCopyWithImpl<$Res, _$LibraryStateImpl>
    implements _$$LibraryStateImplCopyWith<$Res> {
  __$$LibraryStateImplCopyWithImpl(
      _$LibraryStateImpl _value, $Res Function(_$LibraryStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? bookmarkedBranches = null,
    Object? bookmarkedTree = null,
    Object? branches = null,
    Object? currentPageViewIdx = null,
    Object? currentVerticalNavbarIdx = null,
    Object? failureOption = null,
    Object? isProcessing = null,
    Object? session = null,
    Object? trees = null,
  }) {
    return _then(_$LibraryStateImpl(
      bookmarkedBranches: null == bookmarkedBranches
          ? _value._bookmarkedBranches
          : bookmarkedBranches // ignore: cast_nullable_to_non_nullable
              as List<Branch>,
      bookmarkedTree: null == bookmarkedTree
          ? _value._bookmarkedTree
          : bookmarkedTree // ignore: cast_nullable_to_non_nullable
              as List<Tree>,
      branches: null == branches
          ? _value._branches
          : branches // ignore: cast_nullable_to_non_nullable
              as List<Branch>,
      currentPageViewIdx: null == currentPageViewIdx
          ? _value.currentPageViewIdx
          : currentPageViewIdx // ignore: cast_nullable_to_non_nullable
              as int,
      currentVerticalNavbarIdx: null == currentVerticalNavbarIdx
          ? _value.currentVerticalNavbarIdx
          : currentVerticalNavbarIdx // ignore: cast_nullable_to_non_nullable
              as int,
      failureOption: null == failureOption
          ? _value.failureOption
          : failureOption // ignore: cast_nullable_to_non_nullable
              as Option<Result<None<Object>, CoreFailure>>,
      isProcessing: null == isProcessing
          ? _value.isProcessing
          : isProcessing // ignore: cast_nullable_to_non_nullable
              as bool,
      session: null == session
          ? _value.session
          : session // ignore: cast_nullable_to_non_nullable
              as User,
      trees: null == trees
          ? _value._trees
          : trees // ignore: cast_nullable_to_non_nullable
              as List<Tree>,
    ));
  }
}

/// @nodoc

class _$LibraryStateImpl implements _LibraryState {
  const _$LibraryStateImpl(
      {required final List<Branch> bookmarkedBranches,
      required final List<Tree> bookmarkedTree,
      required final List<Branch> branches,
      required this.currentPageViewIdx,
      required this.currentVerticalNavbarIdx,
      required this.failureOption,
      required this.isProcessing,
      required this.session,
      required final List<Tree> trees})
      : _bookmarkedBranches = bookmarkedBranches,
        _bookmarkedTree = bookmarkedTree,
        _branches = branches,
        _trees = trees;

  final List<Branch> _bookmarkedBranches;
  @override
  List<Branch> get bookmarkedBranches {
    if (_bookmarkedBranches is EqualUnmodifiableListView)
      return _bookmarkedBranches;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_bookmarkedBranches);
  }

  final List<Tree> _bookmarkedTree;
  @override
  List<Tree> get bookmarkedTree {
    if (_bookmarkedTree is EqualUnmodifiableListView) return _bookmarkedTree;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_bookmarkedTree);
  }

  final List<Branch> _branches;
  @override
  List<Branch> get branches {
    if (_branches is EqualUnmodifiableListView) return _branches;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_branches);
  }

  @override
  final int currentPageViewIdx;
  @override
  final int currentVerticalNavbarIdx;
  @override
  final Option<Result<None<Object>, CoreFailure>> failureOption;
  @override
  final bool isProcessing;
  @override
  final User session;
  final List<Tree> _trees;
  @override
  List<Tree> get trees {
    if (_trees is EqualUnmodifiableListView) return _trees;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_trees);
  }

  @override
  String toString() {
    return 'LibraryState(bookmarkedBranches: $bookmarkedBranches, bookmarkedTree: $bookmarkedTree, branches: $branches, currentPageViewIdx: $currentPageViewIdx, currentVerticalNavbarIdx: $currentVerticalNavbarIdx, failureOption: $failureOption, isProcessing: $isProcessing, session: $session, trees: $trees)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LibraryStateImpl &&
            const DeepCollectionEquality()
                .equals(other._bookmarkedBranches, _bookmarkedBranches) &&
            const DeepCollectionEquality()
                .equals(other._bookmarkedTree, _bookmarkedTree) &&
            const DeepCollectionEquality().equals(other._branches, _branches) &&
            (identical(other.currentPageViewIdx, currentPageViewIdx) ||
                other.currentPageViewIdx == currentPageViewIdx) &&
            (identical(
                    other.currentVerticalNavbarIdx, currentVerticalNavbarIdx) ||
                other.currentVerticalNavbarIdx == currentVerticalNavbarIdx) &&
            (identical(other.failureOption, failureOption) ||
                other.failureOption == failureOption) &&
            (identical(other.isProcessing, isProcessing) ||
                other.isProcessing == isProcessing) &&
            (identical(other.session, session) || other.session == session) &&
            const DeepCollectionEquality().equals(other._trees, _trees));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_bookmarkedBranches),
      const DeepCollectionEquality().hash(_bookmarkedTree),
      const DeepCollectionEquality().hash(_branches),
      currentPageViewIdx,
      currentVerticalNavbarIdx,
      failureOption,
      isProcessing,
      session,
      const DeepCollectionEquality().hash(_trees));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LibraryStateImplCopyWith<_$LibraryStateImpl> get copyWith =>
      __$$LibraryStateImplCopyWithImpl<_$LibraryStateImpl>(this, _$identity);
}

abstract class _LibraryState implements LibraryState {
  const factory _LibraryState(
      {required final List<Branch> bookmarkedBranches,
      required final List<Tree> bookmarkedTree,
      required final List<Branch> branches,
      required final int currentPageViewIdx,
      required final int currentVerticalNavbarIdx,
      required final Option<Result<None<Object>, CoreFailure>> failureOption,
      required final bool isProcessing,
      required final User session,
      required final List<Tree> trees}) = _$LibraryStateImpl;

  @override
  List<Branch> get bookmarkedBranches;
  @override
  List<Tree> get bookmarkedTree;
  @override
  List<Branch> get branches;
  @override
  int get currentPageViewIdx;
  @override
  int get currentVerticalNavbarIdx;
  @override
  Option<Result<None<Object>, CoreFailure>> get failureOption;
  @override
  bool get isProcessing;
  @override
  User get session;
  @override
  List<Tree> get trees;
  @override
  @JsonKey(ignore: true)
  _$$LibraryStateImplCopyWith<_$LibraryStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
