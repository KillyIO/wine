// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'config_database_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$ConfigDatabaseFailureTearOff {
  const _$ConfigDatabaseFailureTearOff();

// ignore: unused_element
  ConfigNotDeleted configNotDeleted() {
    return const ConfigNotDeleted();
  }

// ignore: unused_element
  ConfigNotInitialized configNotInitialized() {
    return const ConfigNotInitialized();
  }

// ignore: unused_element
  ConfigNotUpdated configNotUpdated() {
    return const ConfigNotUpdated();
  }
}

/// @nodoc
// ignore: unused_element
const $ConfigDatabaseFailure = _$ConfigDatabaseFailureTearOff();

/// @nodoc
mixin _$ConfigDatabaseFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult configNotDeleted(),
    @required TResult configNotInitialized(),
    @required TResult configNotUpdated(),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult configNotDeleted(),
    TResult configNotInitialized(),
    TResult configNotUpdated(),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult configNotDeleted(ConfigNotDeleted value),
    @required TResult configNotInitialized(ConfigNotInitialized value),
    @required TResult configNotUpdated(ConfigNotUpdated value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult configNotDeleted(ConfigNotDeleted value),
    TResult configNotInitialized(ConfigNotInitialized value),
    TResult configNotUpdated(ConfigNotUpdated value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $ConfigDatabaseFailureCopyWith<$Res> {
  factory $ConfigDatabaseFailureCopyWith(ConfigDatabaseFailure value,
          $Res Function(ConfigDatabaseFailure) then) =
      _$ConfigDatabaseFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$ConfigDatabaseFailureCopyWithImpl<$Res>
    implements $ConfigDatabaseFailureCopyWith<$Res> {
  _$ConfigDatabaseFailureCopyWithImpl(this._value, this._then);

  final ConfigDatabaseFailure _value;
  // ignore: unused_field
  final $Res Function(ConfigDatabaseFailure) _then;
}

/// @nodoc
abstract class $ConfigNotDeletedCopyWith<$Res> {
  factory $ConfigNotDeletedCopyWith(
          ConfigNotDeleted value, $Res Function(ConfigNotDeleted) then) =
      _$ConfigNotDeletedCopyWithImpl<$Res>;
}

/// @nodoc
class _$ConfigNotDeletedCopyWithImpl<$Res>
    extends _$ConfigDatabaseFailureCopyWithImpl<$Res>
    implements $ConfigNotDeletedCopyWith<$Res> {
  _$ConfigNotDeletedCopyWithImpl(
      ConfigNotDeleted _value, $Res Function(ConfigNotDeleted) _then)
      : super(_value, (v) => _then(v as ConfigNotDeleted));

  @override
  ConfigNotDeleted get _value => super._value as ConfigNotDeleted;
}

/// @nodoc
class _$ConfigNotDeleted implements ConfigNotDeleted {
  const _$ConfigNotDeleted();

  @override
  String toString() {
    return 'ConfigDatabaseFailure.configNotDeleted()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is ConfigNotDeleted);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult configNotDeleted(),
    @required TResult configNotInitialized(),
    @required TResult configNotUpdated(),
  }) {
    assert(configNotDeleted != null);
    assert(configNotInitialized != null);
    assert(configNotUpdated != null);
    return configNotDeleted();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult configNotDeleted(),
    TResult configNotInitialized(),
    TResult configNotUpdated(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (configNotDeleted != null) {
      return configNotDeleted();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult configNotDeleted(ConfigNotDeleted value),
    @required TResult configNotInitialized(ConfigNotInitialized value),
    @required TResult configNotUpdated(ConfigNotUpdated value),
  }) {
    assert(configNotDeleted != null);
    assert(configNotInitialized != null);
    assert(configNotUpdated != null);
    return configNotDeleted(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult configNotDeleted(ConfigNotDeleted value),
    TResult configNotInitialized(ConfigNotInitialized value),
    TResult configNotUpdated(ConfigNotUpdated value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (configNotDeleted != null) {
      return configNotDeleted(this);
    }
    return orElse();
  }
}

abstract class ConfigNotDeleted implements ConfigDatabaseFailure {
  const factory ConfigNotDeleted() = _$ConfigNotDeleted;
}

/// @nodoc
abstract class $ConfigNotInitializedCopyWith<$Res> {
  factory $ConfigNotInitializedCopyWith(ConfigNotInitialized value,
          $Res Function(ConfigNotInitialized) then) =
      _$ConfigNotInitializedCopyWithImpl<$Res>;
}

/// @nodoc
class _$ConfigNotInitializedCopyWithImpl<$Res>
    extends _$ConfigDatabaseFailureCopyWithImpl<$Res>
    implements $ConfigNotInitializedCopyWith<$Res> {
  _$ConfigNotInitializedCopyWithImpl(
      ConfigNotInitialized _value, $Res Function(ConfigNotInitialized) _then)
      : super(_value, (v) => _then(v as ConfigNotInitialized));

  @override
  ConfigNotInitialized get _value => super._value as ConfigNotInitialized;
}

/// @nodoc
class _$ConfigNotInitialized implements ConfigNotInitialized {
  const _$ConfigNotInitialized();

  @override
  String toString() {
    return 'ConfigDatabaseFailure.configNotInitialized()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is ConfigNotInitialized);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult configNotDeleted(),
    @required TResult configNotInitialized(),
    @required TResult configNotUpdated(),
  }) {
    assert(configNotDeleted != null);
    assert(configNotInitialized != null);
    assert(configNotUpdated != null);
    return configNotInitialized();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult configNotDeleted(),
    TResult configNotInitialized(),
    TResult configNotUpdated(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (configNotInitialized != null) {
      return configNotInitialized();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult configNotDeleted(ConfigNotDeleted value),
    @required TResult configNotInitialized(ConfigNotInitialized value),
    @required TResult configNotUpdated(ConfigNotUpdated value),
  }) {
    assert(configNotDeleted != null);
    assert(configNotInitialized != null);
    assert(configNotUpdated != null);
    return configNotInitialized(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult configNotDeleted(ConfigNotDeleted value),
    TResult configNotInitialized(ConfigNotInitialized value),
    TResult configNotUpdated(ConfigNotUpdated value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (configNotInitialized != null) {
      return configNotInitialized(this);
    }
    return orElse();
  }
}

abstract class ConfigNotInitialized implements ConfigDatabaseFailure {
  const factory ConfigNotInitialized() = _$ConfigNotInitialized;
}

/// @nodoc
abstract class $ConfigNotUpdatedCopyWith<$Res> {
  factory $ConfigNotUpdatedCopyWith(
          ConfigNotUpdated value, $Res Function(ConfigNotUpdated) then) =
      _$ConfigNotUpdatedCopyWithImpl<$Res>;
}

/// @nodoc
class _$ConfigNotUpdatedCopyWithImpl<$Res>
    extends _$ConfigDatabaseFailureCopyWithImpl<$Res>
    implements $ConfigNotUpdatedCopyWith<$Res> {
  _$ConfigNotUpdatedCopyWithImpl(
      ConfigNotUpdated _value, $Res Function(ConfigNotUpdated) _then)
      : super(_value, (v) => _then(v as ConfigNotUpdated));

  @override
  ConfigNotUpdated get _value => super._value as ConfigNotUpdated;
}

/// @nodoc
class _$ConfigNotUpdated implements ConfigNotUpdated {
  const _$ConfigNotUpdated();

  @override
  String toString() {
    return 'ConfigDatabaseFailure.configNotUpdated()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is ConfigNotUpdated);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult configNotDeleted(),
    @required TResult configNotInitialized(),
    @required TResult configNotUpdated(),
  }) {
    assert(configNotDeleted != null);
    assert(configNotInitialized != null);
    assert(configNotUpdated != null);
    return configNotUpdated();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult configNotDeleted(),
    TResult configNotInitialized(),
    TResult configNotUpdated(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (configNotUpdated != null) {
      return configNotUpdated();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult configNotDeleted(ConfigNotDeleted value),
    @required TResult configNotInitialized(ConfigNotInitialized value),
    @required TResult configNotUpdated(ConfigNotUpdated value),
  }) {
    assert(configNotDeleted != null);
    assert(configNotInitialized != null);
    assert(configNotUpdated != null);
    return configNotUpdated(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult configNotDeleted(ConfigNotDeleted value),
    TResult configNotInitialized(ConfigNotInitialized value),
    TResult configNotUpdated(ConfigNotUpdated value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (configNotUpdated != null) {
      return configNotUpdated(this);
    }
    return orElse();
  }
}

abstract class ConfigNotUpdated implements ConfigDatabaseFailure {
  const factory ConfigNotUpdated() = _$ConfigNotUpdated;
}
