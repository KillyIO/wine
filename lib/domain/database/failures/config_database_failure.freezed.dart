// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'config_database_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$ConfigDatabaseFailureTearOff {
  const _$ConfigDatabaseFailureTearOff();

// ignore: unused_element
  DeleteConfigFailure deleteConfigFailure() {
    return const DeleteConfigFailure();
  }

// ignore: unused_element
  InitializeConfigFailure initializeConfigFailure() {
    return const InitializeConfigFailure();
  }

// ignore: unused_element
  UpdateConfigFailure updateConfigFailure() {
    return const UpdateConfigFailure();
  }
}

/// @nodoc
// ignore: unused_element
const $ConfigDatabaseFailure = _$ConfigDatabaseFailureTearOff();

/// @nodoc
mixin _$ConfigDatabaseFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult deleteConfigFailure(),
    @required TResult initializeConfigFailure(),
    @required TResult updateConfigFailure(),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult deleteConfigFailure(),
    TResult initializeConfigFailure(),
    TResult updateConfigFailure(),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult deleteConfigFailure(DeleteConfigFailure value),
    @required TResult initializeConfigFailure(InitializeConfigFailure value),
    @required TResult updateConfigFailure(UpdateConfigFailure value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult deleteConfigFailure(DeleteConfigFailure value),
    TResult initializeConfigFailure(InitializeConfigFailure value),
    TResult updateConfigFailure(UpdateConfigFailure value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $ConfigDatabaseFailureCopyWith<$Res> {
  factory $ConfigDatabaseFailureCopyWith(ConfigDatabaseFailure value,
          $Res Function(ConfigDatabaseFailure) then) =
      _$ConfigDatabaseFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$ConfigDatabaseFailureCopyWithImpl<$Res>
    implements $ConfigDatabaseFailureCopyWith<$Res> {
  _$ConfigDatabaseFailureCopyWithImpl(this._value, this._then);

  final ConfigDatabaseFailure _value;
  // ignore: unused_field
  final $Res Function(ConfigDatabaseFailure) _then;
}

/// @nodoc
abstract class $DeleteConfigFailureCopyWith<$Res> {
  factory $DeleteConfigFailureCopyWith(
          DeleteConfigFailure value, $Res Function(DeleteConfigFailure) then) =
      _$DeleteConfigFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$DeleteConfigFailureCopyWithImpl<$Res>
    extends _$ConfigDatabaseFailureCopyWithImpl<$Res>
    implements $DeleteConfigFailureCopyWith<$Res> {
  _$DeleteConfigFailureCopyWithImpl(
      DeleteConfigFailure _value, $Res Function(DeleteConfigFailure) _then)
      : super(_value, (v) => _then(v as DeleteConfigFailure));

  @override
  DeleteConfigFailure get _value => super._value as DeleteConfigFailure;
}

/// @nodoc
class _$DeleteConfigFailure implements DeleteConfigFailure {
  const _$DeleteConfigFailure();

  @override
  String toString() {
    return 'ConfigDatabaseFailure.deleteConfigFailure()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is DeleteConfigFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult deleteConfigFailure(),
    @required TResult initializeConfigFailure(),
    @required TResult updateConfigFailure(),
  }) {
    assert(deleteConfigFailure != null);
    assert(initializeConfigFailure != null);
    assert(updateConfigFailure != null);
    return deleteConfigFailure();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult deleteConfigFailure(),
    TResult initializeConfigFailure(),
    TResult updateConfigFailure(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (deleteConfigFailure != null) {
      return deleteConfigFailure();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult deleteConfigFailure(DeleteConfigFailure value),
    @required TResult initializeConfigFailure(InitializeConfigFailure value),
    @required TResult updateConfigFailure(UpdateConfigFailure value),
  }) {
    assert(deleteConfigFailure != null);
    assert(initializeConfigFailure != null);
    assert(updateConfigFailure != null);
    return deleteConfigFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult deleteConfigFailure(DeleteConfigFailure value),
    TResult initializeConfigFailure(InitializeConfigFailure value),
    TResult updateConfigFailure(UpdateConfigFailure value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (deleteConfigFailure != null) {
      return deleteConfigFailure(this);
    }
    return orElse();
  }
}

abstract class DeleteConfigFailure implements ConfigDatabaseFailure {
  const factory DeleteConfigFailure() = _$DeleteConfigFailure;
}

/// @nodoc
abstract class $InitializeConfigFailureCopyWith<$Res> {
  factory $InitializeConfigFailureCopyWith(InitializeConfigFailure value,
          $Res Function(InitializeConfigFailure) then) =
      _$InitializeConfigFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$InitializeConfigFailureCopyWithImpl<$Res>
    extends _$ConfigDatabaseFailureCopyWithImpl<$Res>
    implements $InitializeConfigFailureCopyWith<$Res> {
  _$InitializeConfigFailureCopyWithImpl(InitializeConfigFailure _value,
      $Res Function(InitializeConfigFailure) _then)
      : super(_value, (v) => _then(v as InitializeConfigFailure));

  @override
  InitializeConfigFailure get _value => super._value as InitializeConfigFailure;
}

/// @nodoc
class _$InitializeConfigFailure implements InitializeConfigFailure {
  const _$InitializeConfigFailure();

  @override
  String toString() {
    return 'ConfigDatabaseFailure.initializeConfigFailure()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is InitializeConfigFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult deleteConfigFailure(),
    @required TResult initializeConfigFailure(),
    @required TResult updateConfigFailure(),
  }) {
    assert(deleteConfigFailure != null);
    assert(initializeConfigFailure != null);
    assert(updateConfigFailure != null);
    return initializeConfigFailure();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult deleteConfigFailure(),
    TResult initializeConfigFailure(),
    TResult updateConfigFailure(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (initializeConfigFailure != null) {
      return initializeConfigFailure();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult deleteConfigFailure(DeleteConfigFailure value),
    @required TResult initializeConfigFailure(InitializeConfigFailure value),
    @required TResult updateConfigFailure(UpdateConfigFailure value),
  }) {
    assert(deleteConfigFailure != null);
    assert(initializeConfigFailure != null);
    assert(updateConfigFailure != null);
    return initializeConfigFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult deleteConfigFailure(DeleteConfigFailure value),
    TResult initializeConfigFailure(InitializeConfigFailure value),
    TResult updateConfigFailure(UpdateConfigFailure value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (initializeConfigFailure != null) {
      return initializeConfigFailure(this);
    }
    return orElse();
  }
}

abstract class InitializeConfigFailure implements ConfigDatabaseFailure {
  const factory InitializeConfigFailure() = _$InitializeConfigFailure;
}

/// @nodoc
abstract class $UpdateConfigFailureCopyWith<$Res> {
  factory $UpdateConfigFailureCopyWith(
          UpdateConfigFailure value, $Res Function(UpdateConfigFailure) then) =
      _$UpdateConfigFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$UpdateConfigFailureCopyWithImpl<$Res>
    extends _$ConfigDatabaseFailureCopyWithImpl<$Res>
    implements $UpdateConfigFailureCopyWith<$Res> {
  _$UpdateConfigFailureCopyWithImpl(
      UpdateConfigFailure _value, $Res Function(UpdateConfigFailure) _then)
      : super(_value, (v) => _then(v as UpdateConfigFailure));

  @override
  UpdateConfigFailure get _value => super._value as UpdateConfigFailure;
}

/// @nodoc
class _$UpdateConfigFailure implements UpdateConfigFailure {
  const _$UpdateConfigFailure();

  @override
  String toString() {
    return 'ConfigDatabaseFailure.updateConfigFailure()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is UpdateConfigFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult deleteConfigFailure(),
    @required TResult initializeConfigFailure(),
    @required TResult updateConfigFailure(),
  }) {
    assert(deleteConfigFailure != null);
    assert(initializeConfigFailure != null);
    assert(updateConfigFailure != null);
    return updateConfigFailure();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult deleteConfigFailure(),
    TResult initializeConfigFailure(),
    TResult updateConfigFailure(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (updateConfigFailure != null) {
      return updateConfigFailure();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult deleteConfigFailure(DeleteConfigFailure value),
    @required TResult initializeConfigFailure(InitializeConfigFailure value),
    @required TResult updateConfigFailure(UpdateConfigFailure value),
  }) {
    assert(deleteConfigFailure != null);
    assert(initializeConfigFailure != null);
    assert(updateConfigFailure != null);
    return updateConfigFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult deleteConfigFailure(DeleteConfigFailure value),
    TResult initializeConfigFailure(InitializeConfigFailure value),
    TResult updateConfigFailure(UpdateConfigFailure value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (updateConfigFailure != null) {
      return updateConfigFailure(this);
    }
    return orElse();
  }
}

abstract class UpdateConfigFailure implements ConfigDatabaseFailure {
  const factory UpdateConfigFailure() = _$UpdateConfigFailure;
}
