// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'home_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$HomeEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(int index) pageViewIndexChanged,
    required TResult Function() loadNewTree,
    required TResult Function() loadTopTree,
    required TResult Function(String key) loadTreeByGenre,
    required TResult Function(String key) loadTreeByLanguage,
    required TResult Function(String key) loadTreeByTime,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(int index)? pageViewIndexChanged,
    TResult? Function()? loadNewTree,
    TResult? Function()? loadTopTree,
    TResult? Function(String key)? loadTreeByGenre,
    TResult? Function(String key)? loadTreeByLanguage,
    TResult? Function(String key)? loadTreeByTime,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(int index)? pageViewIndexChanged,
    TResult Function()? loadNewTree,
    TResult Function()? loadTopTree,
    TResult Function(String key)? loadTreeByGenre,
    TResult Function(String key)? loadTreeByLanguage,
    TResult Function(String key)? loadTreeByTime,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Init value) init,
    required TResult Function(PageViewIndexChanged value) pageViewIndexChanged,
    required TResult Function(LoadNewTree value) loadNewTree,
    required TResult Function(LoadTopTree value) loadTopTree,
    required TResult Function(LoadTreeByGenre value) loadTreeByGenre,
    required TResult Function(LoadTreeByLanguage value) loadTreeByLanguage,
    required TResult Function(LoadTreeByTime value) loadTreeByTime,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Init value)? init,
    TResult? Function(PageViewIndexChanged value)? pageViewIndexChanged,
    TResult? Function(LoadNewTree value)? loadNewTree,
    TResult? Function(LoadTopTree value)? loadTopTree,
    TResult? Function(LoadTreeByGenre value)? loadTreeByGenre,
    TResult? Function(LoadTreeByLanguage value)? loadTreeByLanguage,
    TResult? Function(LoadTreeByTime value)? loadTreeByTime,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Init value)? init,
    TResult Function(PageViewIndexChanged value)? pageViewIndexChanged,
    TResult Function(LoadNewTree value)? loadNewTree,
    TResult Function(LoadTopTree value)? loadTopTree,
    TResult Function(LoadTreeByGenre value)? loadTreeByGenre,
    TResult Function(LoadTreeByLanguage value)? loadTreeByLanguage,
    TResult Function(LoadTreeByTime value)? loadTreeByTime,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HomeEventCopyWith<$Res> {
  factory $HomeEventCopyWith(HomeEvent value, $Res Function(HomeEvent) then) =
      _$HomeEventCopyWithImpl<$Res, HomeEvent>;
}

/// @nodoc
class _$HomeEventCopyWithImpl<$Res, $Val extends HomeEvent>
    implements $HomeEventCopyWith<$Res> {
  _$HomeEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InitImplCopyWith<$Res> {
  factory _$$InitImplCopyWith(
          _$InitImpl value, $Res Function(_$InitImpl) then) =
      __$$InitImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitImplCopyWithImpl<$Res>
    extends _$HomeEventCopyWithImpl<$Res, _$InitImpl>
    implements _$$InitImplCopyWith<$Res> {
  __$$InitImplCopyWithImpl(_$InitImpl _value, $Res Function(_$InitImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InitImpl implements Init {
  const _$InitImpl();

  @override
  String toString() {
    return 'HomeEvent.init()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(int index) pageViewIndexChanged,
    required TResult Function() loadNewTree,
    required TResult Function() loadTopTree,
    required TResult Function(String key) loadTreeByGenre,
    required TResult Function(String key) loadTreeByLanguage,
    required TResult Function(String key) loadTreeByTime,
  }) {
    return init();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(int index)? pageViewIndexChanged,
    TResult? Function()? loadNewTree,
    TResult? Function()? loadTopTree,
    TResult? Function(String key)? loadTreeByGenre,
    TResult? Function(String key)? loadTreeByLanguage,
    TResult? Function(String key)? loadTreeByTime,
  }) {
    return init?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(int index)? pageViewIndexChanged,
    TResult Function()? loadNewTree,
    TResult Function()? loadTopTree,
    TResult Function(String key)? loadTreeByGenre,
    TResult Function(String key)? loadTreeByLanguage,
    TResult Function(String key)? loadTreeByTime,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Init value) init,
    required TResult Function(PageViewIndexChanged value) pageViewIndexChanged,
    required TResult Function(LoadNewTree value) loadNewTree,
    required TResult Function(LoadTopTree value) loadTopTree,
    required TResult Function(LoadTreeByGenre value) loadTreeByGenre,
    required TResult Function(LoadTreeByLanguage value) loadTreeByLanguage,
    required TResult Function(LoadTreeByTime value) loadTreeByTime,
  }) {
    return init(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Init value)? init,
    TResult? Function(PageViewIndexChanged value)? pageViewIndexChanged,
    TResult? Function(LoadNewTree value)? loadNewTree,
    TResult? Function(LoadTopTree value)? loadTopTree,
    TResult? Function(LoadTreeByGenre value)? loadTreeByGenre,
    TResult? Function(LoadTreeByLanguage value)? loadTreeByLanguage,
    TResult? Function(LoadTreeByTime value)? loadTreeByTime,
  }) {
    return init?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Init value)? init,
    TResult Function(PageViewIndexChanged value)? pageViewIndexChanged,
    TResult Function(LoadNewTree value)? loadNewTree,
    TResult Function(LoadTopTree value)? loadTopTree,
    TResult Function(LoadTreeByGenre value)? loadTreeByGenre,
    TResult Function(LoadTreeByLanguage value)? loadTreeByLanguage,
    TResult Function(LoadTreeByTime value)? loadTreeByTime,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init(this);
    }
    return orElse();
  }
}

abstract class Init implements HomeEvent {
  const factory Init() = _$InitImpl;
}

/// @nodoc
abstract class _$$PageViewIndexChangedImplCopyWith<$Res> {
  factory _$$PageViewIndexChangedImplCopyWith(_$PageViewIndexChangedImpl value,
          $Res Function(_$PageViewIndexChangedImpl) then) =
      __$$PageViewIndexChangedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int index});
}

/// @nodoc
class __$$PageViewIndexChangedImplCopyWithImpl<$Res>
    extends _$HomeEventCopyWithImpl<$Res, _$PageViewIndexChangedImpl>
    implements _$$PageViewIndexChangedImplCopyWith<$Res> {
  __$$PageViewIndexChangedImplCopyWithImpl(_$PageViewIndexChangedImpl _value,
      $Res Function(_$PageViewIndexChangedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
  }) {
    return _then(_$PageViewIndexChangedImpl(
      null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$PageViewIndexChangedImpl implements PageViewIndexChanged {
  const _$PageViewIndexChangedImpl(this.index);

  @override
  final int index;

  @override
  String toString() {
    return 'HomeEvent.pageViewIndexChanged(index: $index)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PageViewIndexChangedImpl &&
            (identical(other.index, index) || other.index == index));
  }

  @override
  int get hashCode => Object.hash(runtimeType, index);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PageViewIndexChangedImplCopyWith<_$PageViewIndexChangedImpl>
      get copyWith =>
          __$$PageViewIndexChangedImplCopyWithImpl<_$PageViewIndexChangedImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(int index) pageViewIndexChanged,
    required TResult Function() loadNewTree,
    required TResult Function() loadTopTree,
    required TResult Function(String key) loadTreeByGenre,
    required TResult Function(String key) loadTreeByLanguage,
    required TResult Function(String key) loadTreeByTime,
  }) {
    return pageViewIndexChanged(index);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(int index)? pageViewIndexChanged,
    TResult? Function()? loadNewTree,
    TResult? Function()? loadTopTree,
    TResult? Function(String key)? loadTreeByGenre,
    TResult? Function(String key)? loadTreeByLanguage,
    TResult? Function(String key)? loadTreeByTime,
  }) {
    return pageViewIndexChanged?.call(index);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(int index)? pageViewIndexChanged,
    TResult Function()? loadNewTree,
    TResult Function()? loadTopTree,
    TResult Function(String key)? loadTreeByGenre,
    TResult Function(String key)? loadTreeByLanguage,
    TResult Function(String key)? loadTreeByTime,
    required TResult orElse(),
  }) {
    if (pageViewIndexChanged != null) {
      return pageViewIndexChanged(index);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Init value) init,
    required TResult Function(PageViewIndexChanged value) pageViewIndexChanged,
    required TResult Function(LoadNewTree value) loadNewTree,
    required TResult Function(LoadTopTree value) loadTopTree,
    required TResult Function(LoadTreeByGenre value) loadTreeByGenre,
    required TResult Function(LoadTreeByLanguage value) loadTreeByLanguage,
    required TResult Function(LoadTreeByTime value) loadTreeByTime,
  }) {
    return pageViewIndexChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Init value)? init,
    TResult? Function(PageViewIndexChanged value)? pageViewIndexChanged,
    TResult? Function(LoadNewTree value)? loadNewTree,
    TResult? Function(LoadTopTree value)? loadTopTree,
    TResult? Function(LoadTreeByGenre value)? loadTreeByGenre,
    TResult? Function(LoadTreeByLanguage value)? loadTreeByLanguage,
    TResult? Function(LoadTreeByTime value)? loadTreeByTime,
  }) {
    return pageViewIndexChanged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Init value)? init,
    TResult Function(PageViewIndexChanged value)? pageViewIndexChanged,
    TResult Function(LoadNewTree value)? loadNewTree,
    TResult Function(LoadTopTree value)? loadTopTree,
    TResult Function(LoadTreeByGenre value)? loadTreeByGenre,
    TResult Function(LoadTreeByLanguage value)? loadTreeByLanguage,
    TResult Function(LoadTreeByTime value)? loadTreeByTime,
    required TResult orElse(),
  }) {
    if (pageViewIndexChanged != null) {
      return pageViewIndexChanged(this);
    }
    return orElse();
  }
}

abstract class PageViewIndexChanged implements HomeEvent {
  const factory PageViewIndexChanged(final int index) =
      _$PageViewIndexChangedImpl;

  int get index;
  @JsonKey(ignore: true)
  _$$PageViewIndexChangedImplCopyWith<_$PageViewIndexChangedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LoadNewTreeImplCopyWith<$Res> {
  factory _$$LoadNewTreeImplCopyWith(
          _$LoadNewTreeImpl value, $Res Function(_$LoadNewTreeImpl) then) =
      __$$LoadNewTreeImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadNewTreeImplCopyWithImpl<$Res>
    extends _$HomeEventCopyWithImpl<$Res, _$LoadNewTreeImpl>
    implements _$$LoadNewTreeImplCopyWith<$Res> {
  __$$LoadNewTreeImplCopyWithImpl(
      _$LoadNewTreeImpl _value, $Res Function(_$LoadNewTreeImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LoadNewTreeImpl implements LoadNewTree {
  const _$LoadNewTreeImpl();

  @override
  String toString() {
    return 'HomeEvent.loadNewTree()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadNewTreeImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(int index) pageViewIndexChanged,
    required TResult Function() loadNewTree,
    required TResult Function() loadTopTree,
    required TResult Function(String key) loadTreeByGenre,
    required TResult Function(String key) loadTreeByLanguage,
    required TResult Function(String key) loadTreeByTime,
  }) {
    return loadNewTree();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(int index)? pageViewIndexChanged,
    TResult? Function()? loadNewTree,
    TResult? Function()? loadTopTree,
    TResult? Function(String key)? loadTreeByGenre,
    TResult? Function(String key)? loadTreeByLanguage,
    TResult? Function(String key)? loadTreeByTime,
  }) {
    return loadNewTree?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(int index)? pageViewIndexChanged,
    TResult Function()? loadNewTree,
    TResult Function()? loadTopTree,
    TResult Function(String key)? loadTreeByGenre,
    TResult Function(String key)? loadTreeByLanguage,
    TResult Function(String key)? loadTreeByTime,
    required TResult orElse(),
  }) {
    if (loadNewTree != null) {
      return loadNewTree();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Init value) init,
    required TResult Function(PageViewIndexChanged value) pageViewIndexChanged,
    required TResult Function(LoadNewTree value) loadNewTree,
    required TResult Function(LoadTopTree value) loadTopTree,
    required TResult Function(LoadTreeByGenre value) loadTreeByGenre,
    required TResult Function(LoadTreeByLanguage value) loadTreeByLanguage,
    required TResult Function(LoadTreeByTime value) loadTreeByTime,
  }) {
    return loadNewTree(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Init value)? init,
    TResult? Function(PageViewIndexChanged value)? pageViewIndexChanged,
    TResult? Function(LoadNewTree value)? loadNewTree,
    TResult? Function(LoadTopTree value)? loadTopTree,
    TResult? Function(LoadTreeByGenre value)? loadTreeByGenre,
    TResult? Function(LoadTreeByLanguage value)? loadTreeByLanguage,
    TResult? Function(LoadTreeByTime value)? loadTreeByTime,
  }) {
    return loadNewTree?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Init value)? init,
    TResult Function(PageViewIndexChanged value)? pageViewIndexChanged,
    TResult Function(LoadNewTree value)? loadNewTree,
    TResult Function(LoadTopTree value)? loadTopTree,
    TResult Function(LoadTreeByGenre value)? loadTreeByGenre,
    TResult Function(LoadTreeByLanguage value)? loadTreeByLanguage,
    TResult Function(LoadTreeByTime value)? loadTreeByTime,
    required TResult orElse(),
  }) {
    if (loadNewTree != null) {
      return loadNewTree(this);
    }
    return orElse();
  }
}

abstract class LoadNewTree implements HomeEvent {
  const factory LoadNewTree() = _$LoadNewTreeImpl;
}

/// @nodoc
abstract class _$$LoadTopTreeImplCopyWith<$Res> {
  factory _$$LoadTopTreeImplCopyWith(
          _$LoadTopTreeImpl value, $Res Function(_$LoadTopTreeImpl) then) =
      __$$LoadTopTreeImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadTopTreeImplCopyWithImpl<$Res>
    extends _$HomeEventCopyWithImpl<$Res, _$LoadTopTreeImpl>
    implements _$$LoadTopTreeImplCopyWith<$Res> {
  __$$LoadTopTreeImplCopyWithImpl(
      _$LoadTopTreeImpl _value, $Res Function(_$LoadTopTreeImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LoadTopTreeImpl implements LoadTopTree {
  const _$LoadTopTreeImpl();

  @override
  String toString() {
    return 'HomeEvent.loadTopTree()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadTopTreeImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(int index) pageViewIndexChanged,
    required TResult Function() loadNewTree,
    required TResult Function() loadTopTree,
    required TResult Function(String key) loadTreeByGenre,
    required TResult Function(String key) loadTreeByLanguage,
    required TResult Function(String key) loadTreeByTime,
  }) {
    return loadTopTree();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(int index)? pageViewIndexChanged,
    TResult? Function()? loadNewTree,
    TResult? Function()? loadTopTree,
    TResult? Function(String key)? loadTreeByGenre,
    TResult? Function(String key)? loadTreeByLanguage,
    TResult? Function(String key)? loadTreeByTime,
  }) {
    return loadTopTree?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(int index)? pageViewIndexChanged,
    TResult Function()? loadNewTree,
    TResult Function()? loadTopTree,
    TResult Function(String key)? loadTreeByGenre,
    TResult Function(String key)? loadTreeByLanguage,
    TResult Function(String key)? loadTreeByTime,
    required TResult orElse(),
  }) {
    if (loadTopTree != null) {
      return loadTopTree();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Init value) init,
    required TResult Function(PageViewIndexChanged value) pageViewIndexChanged,
    required TResult Function(LoadNewTree value) loadNewTree,
    required TResult Function(LoadTopTree value) loadTopTree,
    required TResult Function(LoadTreeByGenre value) loadTreeByGenre,
    required TResult Function(LoadTreeByLanguage value) loadTreeByLanguage,
    required TResult Function(LoadTreeByTime value) loadTreeByTime,
  }) {
    return loadTopTree(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Init value)? init,
    TResult? Function(PageViewIndexChanged value)? pageViewIndexChanged,
    TResult? Function(LoadNewTree value)? loadNewTree,
    TResult? Function(LoadTopTree value)? loadTopTree,
    TResult? Function(LoadTreeByGenre value)? loadTreeByGenre,
    TResult? Function(LoadTreeByLanguage value)? loadTreeByLanguage,
    TResult? Function(LoadTreeByTime value)? loadTreeByTime,
  }) {
    return loadTopTree?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Init value)? init,
    TResult Function(PageViewIndexChanged value)? pageViewIndexChanged,
    TResult Function(LoadNewTree value)? loadNewTree,
    TResult Function(LoadTopTree value)? loadTopTree,
    TResult Function(LoadTreeByGenre value)? loadTreeByGenre,
    TResult Function(LoadTreeByLanguage value)? loadTreeByLanguage,
    TResult Function(LoadTreeByTime value)? loadTreeByTime,
    required TResult orElse(),
  }) {
    if (loadTopTree != null) {
      return loadTopTree(this);
    }
    return orElse();
  }
}

abstract class LoadTopTree implements HomeEvent {
  const factory LoadTopTree() = _$LoadTopTreeImpl;
}

/// @nodoc
abstract class _$$LoadTreeByGenreImplCopyWith<$Res> {
  factory _$$LoadTreeByGenreImplCopyWith(_$LoadTreeByGenreImpl value,
          $Res Function(_$LoadTreeByGenreImpl) then) =
      __$$LoadTreeByGenreImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String key});
}

/// @nodoc
class __$$LoadTreeByGenreImplCopyWithImpl<$Res>
    extends _$HomeEventCopyWithImpl<$Res, _$LoadTreeByGenreImpl>
    implements _$$LoadTreeByGenreImplCopyWith<$Res> {
  __$$LoadTreeByGenreImplCopyWithImpl(
      _$LoadTreeByGenreImpl _value, $Res Function(_$LoadTreeByGenreImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = null,
  }) {
    return _then(_$LoadTreeByGenreImpl(
      null == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$LoadTreeByGenreImpl implements LoadTreeByGenre {
  const _$LoadTreeByGenreImpl(this.key);

  @override
  final String key;

  @override
  String toString() {
    return 'HomeEvent.loadTreeByGenre(key: $key)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadTreeByGenreImpl &&
            (identical(other.key, key) || other.key == key));
  }

  @override
  int get hashCode => Object.hash(runtimeType, key);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LoadTreeByGenreImplCopyWith<_$LoadTreeByGenreImpl> get copyWith =>
      __$$LoadTreeByGenreImplCopyWithImpl<_$LoadTreeByGenreImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(int index) pageViewIndexChanged,
    required TResult Function() loadNewTree,
    required TResult Function() loadTopTree,
    required TResult Function(String key) loadTreeByGenre,
    required TResult Function(String key) loadTreeByLanguage,
    required TResult Function(String key) loadTreeByTime,
  }) {
    return loadTreeByGenre(key);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(int index)? pageViewIndexChanged,
    TResult? Function()? loadNewTree,
    TResult? Function()? loadTopTree,
    TResult? Function(String key)? loadTreeByGenre,
    TResult? Function(String key)? loadTreeByLanguage,
    TResult? Function(String key)? loadTreeByTime,
  }) {
    return loadTreeByGenre?.call(key);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(int index)? pageViewIndexChanged,
    TResult Function()? loadNewTree,
    TResult Function()? loadTopTree,
    TResult Function(String key)? loadTreeByGenre,
    TResult Function(String key)? loadTreeByLanguage,
    TResult Function(String key)? loadTreeByTime,
    required TResult orElse(),
  }) {
    if (loadTreeByGenre != null) {
      return loadTreeByGenre(key);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Init value) init,
    required TResult Function(PageViewIndexChanged value) pageViewIndexChanged,
    required TResult Function(LoadNewTree value) loadNewTree,
    required TResult Function(LoadTopTree value) loadTopTree,
    required TResult Function(LoadTreeByGenre value) loadTreeByGenre,
    required TResult Function(LoadTreeByLanguage value) loadTreeByLanguage,
    required TResult Function(LoadTreeByTime value) loadTreeByTime,
  }) {
    return loadTreeByGenre(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Init value)? init,
    TResult? Function(PageViewIndexChanged value)? pageViewIndexChanged,
    TResult? Function(LoadNewTree value)? loadNewTree,
    TResult? Function(LoadTopTree value)? loadTopTree,
    TResult? Function(LoadTreeByGenre value)? loadTreeByGenre,
    TResult? Function(LoadTreeByLanguage value)? loadTreeByLanguage,
    TResult? Function(LoadTreeByTime value)? loadTreeByTime,
  }) {
    return loadTreeByGenre?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Init value)? init,
    TResult Function(PageViewIndexChanged value)? pageViewIndexChanged,
    TResult Function(LoadNewTree value)? loadNewTree,
    TResult Function(LoadTopTree value)? loadTopTree,
    TResult Function(LoadTreeByGenre value)? loadTreeByGenre,
    TResult Function(LoadTreeByLanguage value)? loadTreeByLanguage,
    TResult Function(LoadTreeByTime value)? loadTreeByTime,
    required TResult orElse(),
  }) {
    if (loadTreeByGenre != null) {
      return loadTreeByGenre(this);
    }
    return orElse();
  }
}

abstract class LoadTreeByGenre implements HomeEvent {
  const factory LoadTreeByGenre(final String key) = _$LoadTreeByGenreImpl;

  String get key;
  @JsonKey(ignore: true)
  _$$LoadTreeByGenreImplCopyWith<_$LoadTreeByGenreImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LoadTreeByLanguageImplCopyWith<$Res> {
  factory _$$LoadTreeByLanguageImplCopyWith(_$LoadTreeByLanguageImpl value,
          $Res Function(_$LoadTreeByLanguageImpl) then) =
      __$$LoadTreeByLanguageImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String key});
}

/// @nodoc
class __$$LoadTreeByLanguageImplCopyWithImpl<$Res>
    extends _$HomeEventCopyWithImpl<$Res, _$LoadTreeByLanguageImpl>
    implements _$$LoadTreeByLanguageImplCopyWith<$Res> {
  __$$LoadTreeByLanguageImplCopyWithImpl(_$LoadTreeByLanguageImpl _value,
      $Res Function(_$LoadTreeByLanguageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = null,
  }) {
    return _then(_$LoadTreeByLanguageImpl(
      null == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$LoadTreeByLanguageImpl implements LoadTreeByLanguage {
  const _$LoadTreeByLanguageImpl(this.key);

  @override
  final String key;

  @override
  String toString() {
    return 'HomeEvent.loadTreeByLanguage(key: $key)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadTreeByLanguageImpl &&
            (identical(other.key, key) || other.key == key));
  }

  @override
  int get hashCode => Object.hash(runtimeType, key);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LoadTreeByLanguageImplCopyWith<_$LoadTreeByLanguageImpl> get copyWith =>
      __$$LoadTreeByLanguageImplCopyWithImpl<_$LoadTreeByLanguageImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(int index) pageViewIndexChanged,
    required TResult Function() loadNewTree,
    required TResult Function() loadTopTree,
    required TResult Function(String key) loadTreeByGenre,
    required TResult Function(String key) loadTreeByLanguage,
    required TResult Function(String key) loadTreeByTime,
  }) {
    return loadTreeByLanguage(key);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(int index)? pageViewIndexChanged,
    TResult? Function()? loadNewTree,
    TResult? Function()? loadTopTree,
    TResult? Function(String key)? loadTreeByGenre,
    TResult? Function(String key)? loadTreeByLanguage,
    TResult? Function(String key)? loadTreeByTime,
  }) {
    return loadTreeByLanguage?.call(key);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(int index)? pageViewIndexChanged,
    TResult Function()? loadNewTree,
    TResult Function()? loadTopTree,
    TResult Function(String key)? loadTreeByGenre,
    TResult Function(String key)? loadTreeByLanguage,
    TResult Function(String key)? loadTreeByTime,
    required TResult orElse(),
  }) {
    if (loadTreeByLanguage != null) {
      return loadTreeByLanguage(key);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Init value) init,
    required TResult Function(PageViewIndexChanged value) pageViewIndexChanged,
    required TResult Function(LoadNewTree value) loadNewTree,
    required TResult Function(LoadTopTree value) loadTopTree,
    required TResult Function(LoadTreeByGenre value) loadTreeByGenre,
    required TResult Function(LoadTreeByLanguage value) loadTreeByLanguage,
    required TResult Function(LoadTreeByTime value) loadTreeByTime,
  }) {
    return loadTreeByLanguage(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Init value)? init,
    TResult? Function(PageViewIndexChanged value)? pageViewIndexChanged,
    TResult? Function(LoadNewTree value)? loadNewTree,
    TResult? Function(LoadTopTree value)? loadTopTree,
    TResult? Function(LoadTreeByGenre value)? loadTreeByGenre,
    TResult? Function(LoadTreeByLanguage value)? loadTreeByLanguage,
    TResult? Function(LoadTreeByTime value)? loadTreeByTime,
  }) {
    return loadTreeByLanguage?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Init value)? init,
    TResult Function(PageViewIndexChanged value)? pageViewIndexChanged,
    TResult Function(LoadNewTree value)? loadNewTree,
    TResult Function(LoadTopTree value)? loadTopTree,
    TResult Function(LoadTreeByGenre value)? loadTreeByGenre,
    TResult Function(LoadTreeByLanguage value)? loadTreeByLanguage,
    TResult Function(LoadTreeByTime value)? loadTreeByTime,
    required TResult orElse(),
  }) {
    if (loadTreeByLanguage != null) {
      return loadTreeByLanguage(this);
    }
    return orElse();
  }
}

abstract class LoadTreeByLanguage implements HomeEvent {
  const factory LoadTreeByLanguage(final String key) = _$LoadTreeByLanguageImpl;

  String get key;
  @JsonKey(ignore: true)
  _$$LoadTreeByLanguageImplCopyWith<_$LoadTreeByLanguageImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LoadTreeByTimeImplCopyWith<$Res> {
  factory _$$LoadTreeByTimeImplCopyWith(_$LoadTreeByTimeImpl value,
          $Res Function(_$LoadTreeByTimeImpl) then) =
      __$$LoadTreeByTimeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String key});
}

/// @nodoc
class __$$LoadTreeByTimeImplCopyWithImpl<$Res>
    extends _$HomeEventCopyWithImpl<$Res, _$LoadTreeByTimeImpl>
    implements _$$LoadTreeByTimeImplCopyWith<$Res> {
  __$$LoadTreeByTimeImplCopyWithImpl(
      _$LoadTreeByTimeImpl _value, $Res Function(_$LoadTreeByTimeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = null,
  }) {
    return _then(_$LoadTreeByTimeImpl(
      null == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$LoadTreeByTimeImpl implements LoadTreeByTime {
  const _$LoadTreeByTimeImpl(this.key);

  @override
  final String key;

  @override
  String toString() {
    return 'HomeEvent.loadTreeByTime(key: $key)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadTreeByTimeImpl &&
            (identical(other.key, key) || other.key == key));
  }

  @override
  int get hashCode => Object.hash(runtimeType, key);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LoadTreeByTimeImplCopyWith<_$LoadTreeByTimeImpl> get copyWith =>
      __$$LoadTreeByTimeImplCopyWithImpl<_$LoadTreeByTimeImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(int index) pageViewIndexChanged,
    required TResult Function() loadNewTree,
    required TResult Function() loadTopTree,
    required TResult Function(String key) loadTreeByGenre,
    required TResult Function(String key) loadTreeByLanguage,
    required TResult Function(String key) loadTreeByTime,
  }) {
    return loadTreeByTime(key);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(int index)? pageViewIndexChanged,
    TResult? Function()? loadNewTree,
    TResult? Function()? loadTopTree,
    TResult? Function(String key)? loadTreeByGenre,
    TResult? Function(String key)? loadTreeByLanguage,
    TResult? Function(String key)? loadTreeByTime,
  }) {
    return loadTreeByTime?.call(key);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(int index)? pageViewIndexChanged,
    TResult Function()? loadNewTree,
    TResult Function()? loadTopTree,
    TResult Function(String key)? loadTreeByGenre,
    TResult Function(String key)? loadTreeByLanguage,
    TResult Function(String key)? loadTreeByTime,
    required TResult orElse(),
  }) {
    if (loadTreeByTime != null) {
      return loadTreeByTime(key);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Init value) init,
    required TResult Function(PageViewIndexChanged value) pageViewIndexChanged,
    required TResult Function(LoadNewTree value) loadNewTree,
    required TResult Function(LoadTopTree value) loadTopTree,
    required TResult Function(LoadTreeByGenre value) loadTreeByGenre,
    required TResult Function(LoadTreeByLanguage value) loadTreeByLanguage,
    required TResult Function(LoadTreeByTime value) loadTreeByTime,
  }) {
    return loadTreeByTime(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Init value)? init,
    TResult? Function(PageViewIndexChanged value)? pageViewIndexChanged,
    TResult? Function(LoadNewTree value)? loadNewTree,
    TResult? Function(LoadTopTree value)? loadTopTree,
    TResult? Function(LoadTreeByGenre value)? loadTreeByGenre,
    TResult? Function(LoadTreeByLanguage value)? loadTreeByLanguage,
    TResult? Function(LoadTreeByTime value)? loadTreeByTime,
  }) {
    return loadTreeByTime?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Init value)? init,
    TResult Function(PageViewIndexChanged value)? pageViewIndexChanged,
    TResult Function(LoadNewTree value)? loadNewTree,
    TResult Function(LoadTopTree value)? loadTopTree,
    TResult Function(LoadTreeByGenre value)? loadTreeByGenre,
    TResult Function(LoadTreeByLanguage value)? loadTreeByLanguage,
    TResult Function(LoadTreeByTime value)? loadTreeByTime,
    required TResult orElse(),
  }) {
    if (loadTreeByTime != null) {
      return loadTreeByTime(this);
    }
    return orElse();
  }
}

abstract class LoadTreeByTime implements HomeEvent {
  const factory LoadTreeByTime(final String key) = _$LoadTreeByTimeImpl;

  String get key;
  @JsonKey(ignore: true)
  _$$LoadTreeByTimeImplCopyWith<_$LoadTreeByTimeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$HomeState {
  int get currentPageViewIdx => throw _privateConstructorUsedError;
  Option<Result<Unit, CoreFailure>> get failureOption =>
      throw _privateConstructorUsedError;
  String get genreFilterKey => throw _privateConstructorUsedError;
  bool get isProcessing => throw _privateConstructorUsedError;
  String get languageFilterKey => throw _privateConstructorUsedError;
  List<Tree> get newTrees => throw _privateConstructorUsedError;
  String get timeFilterKey => throw _privateConstructorUsedError;
  List<Tree> get topTrees => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $HomeStateCopyWith<HomeState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HomeStateCopyWith<$Res> {
  factory $HomeStateCopyWith(HomeState value, $Res Function(HomeState) then) =
      _$HomeStateCopyWithImpl<$Res, HomeState>;
  @useResult
  $Res call(
      {int currentPageViewIdx,
      Option<Result<Unit, CoreFailure>> failureOption,
      String genreFilterKey,
      bool isProcessing,
      String languageFilterKey,
      List<Tree> newTrees,
      String timeFilterKey,
      List<Tree> topTrees});
}

/// @nodoc
class _$HomeStateCopyWithImpl<$Res, $Val extends HomeState>
    implements $HomeStateCopyWith<$Res> {
  _$HomeStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? currentPageViewIdx = null,
    Object? failureOption = null,
    Object? genreFilterKey = null,
    Object? isProcessing = null,
    Object? languageFilterKey = null,
    Object? newTrees = null,
    Object? timeFilterKey = null,
    Object? topTrees = null,
  }) {
    return _then(_value.copyWith(
      currentPageViewIdx: null == currentPageViewIdx
          ? _value.currentPageViewIdx
          : currentPageViewIdx // ignore: cast_nullable_to_non_nullable
              as int,
      failureOption: null == failureOption
          ? _value.failureOption
          : failureOption // ignore: cast_nullable_to_non_nullable
              as Option<Result<Unit, CoreFailure>>,
      genreFilterKey: null == genreFilterKey
          ? _value.genreFilterKey
          : genreFilterKey // ignore: cast_nullable_to_non_nullable
              as String,
      isProcessing: null == isProcessing
          ? _value.isProcessing
          : isProcessing // ignore: cast_nullable_to_non_nullable
              as bool,
      languageFilterKey: null == languageFilterKey
          ? _value.languageFilterKey
          : languageFilterKey // ignore: cast_nullable_to_non_nullable
              as String,
      newTrees: null == newTrees
          ? _value.newTrees
          : newTrees // ignore: cast_nullable_to_non_nullable
              as List<Tree>,
      timeFilterKey: null == timeFilterKey
          ? _value.timeFilterKey
          : timeFilterKey // ignore: cast_nullable_to_non_nullable
              as String,
      topTrees: null == topTrees
          ? _value.topTrees
          : topTrees // ignore: cast_nullable_to_non_nullable
              as List<Tree>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$HomeStateImplCopyWith<$Res>
    implements $HomeStateCopyWith<$Res> {
  factory _$$HomeStateImplCopyWith(
          _$HomeStateImpl value, $Res Function(_$HomeStateImpl) then) =
      __$$HomeStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int currentPageViewIdx,
      Option<Result<Unit, CoreFailure>> failureOption,
      String genreFilterKey,
      bool isProcessing,
      String languageFilterKey,
      List<Tree> newTrees,
      String timeFilterKey,
      List<Tree> topTrees});
}

/// @nodoc
class __$$HomeStateImplCopyWithImpl<$Res>
    extends _$HomeStateCopyWithImpl<$Res, _$HomeStateImpl>
    implements _$$HomeStateImplCopyWith<$Res> {
  __$$HomeStateImplCopyWithImpl(
      _$HomeStateImpl _value, $Res Function(_$HomeStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? currentPageViewIdx = null,
    Object? failureOption = null,
    Object? genreFilterKey = null,
    Object? isProcessing = null,
    Object? languageFilterKey = null,
    Object? newTrees = null,
    Object? timeFilterKey = null,
    Object? topTrees = null,
  }) {
    return _then(_$HomeStateImpl(
      currentPageViewIdx: null == currentPageViewIdx
          ? _value.currentPageViewIdx
          : currentPageViewIdx // ignore: cast_nullable_to_non_nullable
              as int,
      failureOption: null == failureOption
          ? _value.failureOption
          : failureOption // ignore: cast_nullable_to_non_nullable
              as Option<Result<Unit, CoreFailure>>,
      genreFilterKey: null == genreFilterKey
          ? _value.genreFilterKey
          : genreFilterKey // ignore: cast_nullable_to_non_nullable
              as String,
      isProcessing: null == isProcessing
          ? _value.isProcessing
          : isProcessing // ignore: cast_nullable_to_non_nullable
              as bool,
      languageFilterKey: null == languageFilterKey
          ? _value.languageFilterKey
          : languageFilterKey // ignore: cast_nullable_to_non_nullable
              as String,
      newTrees: null == newTrees
          ? _value._newTrees
          : newTrees // ignore: cast_nullable_to_non_nullable
              as List<Tree>,
      timeFilterKey: null == timeFilterKey
          ? _value.timeFilterKey
          : timeFilterKey // ignore: cast_nullable_to_non_nullable
              as String,
      topTrees: null == topTrees
          ? _value._topTrees
          : topTrees // ignore: cast_nullable_to_non_nullable
              as List<Tree>,
    ));
  }
}

/// @nodoc

class _$HomeStateImpl implements _HomeState {
  const _$HomeStateImpl(
      {required this.currentPageViewIdx,
      required this.failureOption,
      required this.genreFilterKey,
      required this.isProcessing,
      required this.languageFilterKey,
      required final List<Tree> newTrees,
      required this.timeFilterKey,
      required final List<Tree> topTrees})
      : _newTrees = newTrees,
        _topTrees = topTrees;

  @override
  final int currentPageViewIdx;
  @override
  final Option<Result<Unit, CoreFailure>> failureOption;
  @override
  final String genreFilterKey;
  @override
  final bool isProcessing;
  @override
  final String languageFilterKey;
  final List<Tree> _newTrees;
  @override
  List<Tree> get newTrees {
    if (_newTrees is EqualUnmodifiableListView) return _newTrees;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_newTrees);
  }

  @override
  final String timeFilterKey;
  final List<Tree> _topTrees;
  @override
  List<Tree> get topTrees {
    if (_topTrees is EqualUnmodifiableListView) return _topTrees;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_topTrees);
  }

  @override
  String toString() {
    return 'HomeState(currentPageViewIdx: $currentPageViewIdx, failureOption: $failureOption, genreFilterKey: $genreFilterKey, isProcessing: $isProcessing, languageFilterKey: $languageFilterKey, newTrees: $newTrees, timeFilterKey: $timeFilterKey, topTrees: $topTrees)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HomeStateImpl &&
            (identical(other.currentPageViewIdx, currentPageViewIdx) ||
                other.currentPageViewIdx == currentPageViewIdx) &&
            (identical(other.failureOption, failureOption) ||
                other.failureOption == failureOption) &&
            (identical(other.genreFilterKey, genreFilterKey) ||
                other.genreFilterKey == genreFilterKey) &&
            (identical(other.isProcessing, isProcessing) ||
                other.isProcessing == isProcessing) &&
            (identical(other.languageFilterKey, languageFilterKey) ||
                other.languageFilterKey == languageFilterKey) &&
            const DeepCollectionEquality().equals(other._newTrees, _newTrees) &&
            (identical(other.timeFilterKey, timeFilterKey) ||
                other.timeFilterKey == timeFilterKey) &&
            const DeepCollectionEquality().equals(other._topTrees, _topTrees));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      currentPageViewIdx,
      failureOption,
      genreFilterKey,
      isProcessing,
      languageFilterKey,
      const DeepCollectionEquality().hash(_newTrees),
      timeFilterKey,
      const DeepCollectionEquality().hash(_topTrees));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$HomeStateImplCopyWith<_$HomeStateImpl> get copyWith =>
      __$$HomeStateImplCopyWithImpl<_$HomeStateImpl>(this, _$identity);
}

abstract class _HomeState implements HomeState {
  const factory _HomeState(
      {required final int currentPageViewIdx,
      required final Option<Result<Unit, CoreFailure>> failureOption,
      required final String genreFilterKey,
      required final bool isProcessing,
      required final String languageFilterKey,
      required final List<Tree> newTrees,
      required final String timeFilterKey,
      required final List<Tree> topTrees}) = _$HomeStateImpl;

  @override
  int get currentPageViewIdx;
  @override
  Option<Result<Unit, CoreFailure>> get failureOption;
  @override
  String get genreFilterKey;
  @override
  bool get isProcessing;
  @override
  String get languageFilterKey;
  @override
  List<Tree> get newTrees;
  @override
  String get timeFilterKey;
  @override
  List<Tree> get topTrees;
  @override
  @JsonKey(ignore: true)
  _$$HomeStateImplCopyWith<_$HomeStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
